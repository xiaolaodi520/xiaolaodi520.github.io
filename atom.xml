<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>小老弟</title>
  
  <subtitle>hexo博客</subtitle>
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2022-01-17T14:01:17.520Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>xiaolaodi520</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>C++数组或vector的最大最小值</title>
    <link href="http://example.com/2022/01/17/C++%E6%95%B0%E7%BB%84%E6%88%96vector%E7%9A%84%E6%9C%80%E5%A4%A7%E6%9C%80%E5%B0%8F%E5%80%BC/"/>
    <id>http://example.com/2022/01/17/C++%E6%95%B0%E7%BB%84%E6%88%96vector%E7%9A%84%E6%9C%80%E5%A4%A7%E6%9C%80%E5%B0%8F%E5%80%BC/</id>
    <published>2022-01-17T13:58:32.000Z</published>
    <updated>2022-01-17T14:01:17.520Z</updated>
    
    <content type="html"><![CDATA[<p><strong>头文件：#include<algorithm></algorithm></strong><br>1）vector容器</p><p>例 vector<int> vec</int></p><p>最大值：int maxValue = *max_element(v.begin(),v.end()); </p><p>最小值：int minValue = *min_element(v.begin(),v.end());</p><p>2）普通数组</p><p>例 a[]={1,2,3,4,5,6};</p><p>最大值：int maxValue = *max_element(a,a+6); </p><p>最小值：int minValue = *min_element(a,a+6);</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;strong&gt;头文件：#include&lt;algorithm&gt;&lt;/algorithm&gt;&lt;/strong&gt;&lt;br&gt;1）vector容器&lt;/p&gt;
&lt;p&gt;例 vector&lt;int&gt; vec&lt;/int&gt;&lt;/p&gt;
&lt;p&gt;最大值：int maxValue = *max_element(</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>寒假每日一题</title>
    <link href="http://example.com/2022/01/17/acwing2022%E5%AF%92%E5%81%87%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98week3/"/>
    <id>http://example.com/2022/01/17/acwing2022%E5%AF%92%E5%81%87%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98week3/</id>
    <published>2022-01-17T09:09:30.000Z</published>
    <updated>2022-01-21T15:00:43.800Z</updated>
    
    <content type="html"><![CDATA[<h1 id="01-17-1934-贝茜放慢脚步"><a href="#01-17-1934-贝茜放慢脚步" class="headerlink" title="01-17 1934.贝茜放慢脚步"></a><strong>01-17 1934.贝茜放慢脚步</strong></h1><p><strong>题目链接：</strong><a href="https://www.acwing.com/problem/content/1936/">1934.贝茜放慢脚步</a><br><strong>代码如下：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int N &#x3D; 10010;</span><br><span class="line"></span><br><span class="line">int n;</span><br><span class="line">vector&lt;int&gt; a, b;&#x2F;&#x2F;减速的时间和距离</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    scanf(&quot;%d&quot;, &amp;n);&#x2F;&#x2F;读入减速次数</span><br><span class="line">    char str[2];</span><br><span class="line">    int x;&#x2F;&#x2F;存入每一个数据x，添加至向量中</span><br><span class="line">    while (n -- )</span><br><span class="line">    &#123;</span><br><span class="line">        scanf(&quot;%s%d&quot;, str, &amp;x);&#x2F;&#x2F;读入减速时间和距离</span><br><span class="line"></span><br><span class="line">        if (*str &#x3D;&#x3D; &#39;T&#39;) a.push_back(x);&#x2F;&#x2F;时间存储到a</span><br><span class="line">        else b.push_back(x);&#x2F;&#x2F;距离存储到b</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    b.push_back(1000);&#x2F;&#x2F;总距离是1000</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;将两个数组排序</span><br><span class="line">    sort(a.begin(), a.end());</span><br><span class="line">    sort(b.begin(), b.end());</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;对了两个数组进行运算得到</span><br><span class="line">    double t &#x3D; 0, s &#x3D; 0, v &#x3D; 1;  &#x2F;&#x2F; v 是速度的倒数</span><br><span class="line">    int i &#x3D; 0, j &#x3D; 0;</span><br><span class="line">    while (i &lt; a.size() || j &lt; b.size())&#x2F;&#x2F;只要有一个没有超出就循环</span><br><span class="line">        if (j &#x3D;&#x3D; b.size() || i &lt; a.size() &amp;&amp; a[i] - t &lt; (b[j] - s) * v)&#x2F;&#x2F;时间比距离更早并且a没有走完&#x2F;&#x2F;if条件先判断与再判断或</span><br><span class="line">        &#123;</span><br><span class="line">            s +&#x3D; (a[i] - t) &#x2F; v;&#x2F;&#x2F;前进的距离</span><br><span class="line">            t &#x3D; a[i];&#x2F;&#x2F;经历的时间</span><br><span class="line">            v ++ ;</span><br><span class="line">            i ++ ;</span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">        &#123;</span><br><span class="line">            t +&#x3D; (b[j] - s) * v;</span><br><span class="line">            s &#x3D; b[j];</span><br><span class="line">            v ++ ;</span><br><span class="line">            j ++ ;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    printf(&quot;%.0lf\n&quot;, t);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="01-18-AcWing-1929-镜子田地"><a href="#01-18-AcWing-1929-镜子田地" class="headerlink" title="01-18 AcWing 1929. 镜子田地"></a><strong>01-18 AcWing 1929. 镜子田地</strong></h1><p><strong>原题链接：</strong><a href="https://www.acwing.com/problem/content/1931/">AcWing 1929. 镜子田地</a><br><strong>代码如下：</strong></p><p>#include <iostream></iostream></p><p>using namespace std;</p><p>const int N=1010;<br>char g[N][N];<br>int dx[4]={-1,0,1,0},dy[4]={0,1,0,-1};<br>int n,m;</p><p>int dfs(int x,int y ,int d)<br>{<br>    if(x&lt;0||y&lt;0||x&gt;n-1||y&gt;m-1) return 0;<br>    if(g[x][y]==’/‘) d^=1;<br>    else d^=3;<br>    return dfs(x+dx[d],y+dy[d],d)+1;<br>}<br>int main()<br>{<br>    scanf(“%d%d”,&amp;n,&amp;m);<br>    for(int i=0;i&lt;n;i++)<br>        scanf(“%s”,g[i]);</p><pre><code>int res=0;for(int i=0;i&lt;n;i++)&#123;    res=max(res,dfs(i,0,1));    res=max(res,dfs(i,m-1,3));&#125;for(int i=0;i&lt;m;i++)&#123;    res=max(res,dfs(0,i,2));    res=max(res,dfs(n-1,i,0));&#125;printf(&quot;%d&quot;,res);return 0;</code></pre><p>}</p><h1 id="01-19-AcWing-1922-懒惰的牛"><a href="#01-19-AcWing-1922-懒惰的牛" class="headerlink" title="01-19 AcWing 1922. 懒惰的牛"></a><strong>01-19 AcWing 1922. 懒惰的牛</strong></h1><p><strong>题目链接：</strong><a href="https://www.acwing.com/problem/content/1924/">AcWing 1922. 懒惰的牛</a><br><strong>代码如下：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int MAP[1000010]&#x3D;&#123;0&#125;;</span><br><span class="line">vector&lt;int&gt; x;</span><br><span class="line">int n,k;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int a,b;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; k;</span><br><span class="line">    for(int i&#x3D;0;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        scanf(&quot;%d%d&quot;,&amp;a,&amp;b);</span><br><span class="line">        MAP[b]&#x3D;a;</span><br><span class="line">        x.push_back(b);</span><br><span class="line">    &#125;</span><br><span class="line">    sort(x.begin(),x.end());</span><br><span class="line"></span><br><span class="line">    int sum&#x3D;0,max_sum&#x3D;0;</span><br><span class="line">    int i&#x3D;0,j&#x3D;0;</span><br><span class="line">    for(i&#x3D;0;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        sum+&#x3D;MAP[x[i]];</span><br><span class="line">        while(x[i]-x[j]&gt;2*k) sum-&#x3D;MAP[x[j++]];</span><br><span class="line">        max_sum&#x3D;max(max_sum,sum);</span><br><span class="line">    &#125;</span><br><span class="line">    printf(&quot;%d&quot;,max_sum);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="01-20-AcWing-1913-公平摄影"><a href="#01-20-AcWing-1913-公平摄影" class="headerlink" title="01-20 AcWing 1913. 公平摄影"></a><strong>01-20 AcWing 1913. 公平摄影</strong></h1><p><strong>题目链接：</strong><a href="https://www.acwing.com/problem/content/1915/">AcWing 1913. 公平摄影</a><br><strong>代码如下：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;代码待写</span><br></pre></td></tr></table></figure><h1 id="01-21-AcWing-1904-奶牛慢跑"><a href="#01-21-AcWing-1904-奶牛慢跑" class="headerlink" title="01-21 AcWing 1904. 奶牛慢跑"></a><strong>01-21 AcWing 1904. 奶牛慢跑</strong></h1><p><strong>题目链接：</strong><a href="https://www.acwing.com/problem/content/1906/">AcWing 1904. 奶牛慢跑</a><br><strong>代码如下：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int N&#x3D;1e5+50;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int n;</span><br><span class="line">    scanf(&quot;%d&quot;,&amp;n);</span><br><span class="line">    int d[N],v[N];</span><br><span class="line">    int sum&#x3D;1;</span><br><span class="line">    for(int i&#x3D;n;i&gt;0;i--)</span><br><span class="line">        scanf(&quot;%d%d&quot;,&amp;d[n-i],&amp;v[n-i]);</span><br><span class="line"></span><br><span class="line">    int min_v&#x3D;v[n-1];</span><br><span class="line">    n--;</span><br><span class="line">    while(n--)</span><br><span class="line">    &#123;</span><br><span class="line">        if(v[n]&lt;&#x3D;min_v)</span><br><span class="line">        &#123;</span><br><span class="line">            sum++;</span><br><span class="line">            min_v&#x3D;v[n];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    printf(&quot;%d\n&quot; , sum);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="01-23"><a href="#01-23" class="headerlink" title="**01-23 **"></a>**01-23 **</h1>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;01-17-1934-贝茜放慢脚步&quot;&gt;&lt;a href=&quot;#01-17-1934-贝茜放慢脚步&quot; class=&quot;headerlink&quot; title=&quot;01-17 1934.贝茜放慢脚步&quot;&gt;&lt;/a&gt;&lt;strong&gt;01-17 1934.贝茜放慢脚步&lt;/strong&gt;&lt;</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>AcWing 785. 快速排序</title>
    <link href="http://example.com/2021/10/10/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/"/>
    <id>http://example.com/2021/10/10/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/</id>
    <published>2021-10-10T08:00:28.000Z</published>
    <updated>2021-10-10T08:06:07.639Z</updated>
    
    <content type="html"><![CDATA[<p>有些情况下取中间比去两边更快</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int N &#x3D; 1000010;</span><br><span class="line"></span><br><span class="line">int q[N];</span><br><span class="line"></span><br><span class="line">void quick_sort(int q[], int l, int r)</span><br><span class="line">&#123;</span><br><span class="line">    if (l &gt;&#x3D; r) return;</span><br><span class="line"></span><br><span class="line">    int i &#x3D; l - 1, j &#x3D; r + 1, x &#x3D; q[(l+r)&#x2F;2];</span><br><span class="line">    while (i &lt; j)</span><br><span class="line">    &#123;</span><br><span class="line">        do i ++ ; while (q[i] &lt; x);</span><br><span class="line">        do j -- ; while (q[j] &gt; x);</span><br><span class="line">        if (i &lt; j) swap(q[i], q[j]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    quick_sort(q, l, j);</span><br><span class="line">    quick_sort(q, j + 1, r);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int n;</span><br><span class="line">    scanf(&quot;%d&quot;, &amp;n);</span><br><span class="line"></span><br><span class="line">    for (int i &#x3D; 0; i &lt; n; i ++ ) scanf(&quot;%d&quot;, &amp;q[i]);</span><br><span class="line"></span><br><span class="line">    quick_sort(q, 0, n - 1);</span><br><span class="line"></span><br><span class="line">    for (int i &#x3D; 0; i &lt; n; i ++ ) printf(&quot;%d &quot;, q[i]);</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;有些情况下取中间比去两边更快&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>scanf（）与scanf_s（）函数</title>
    <link href="http://example.com/2021/10/10/scanf%EF%BC%88%EF%BC%89%E4%B8%8Escanf-s%EF%BC%88%EF%BC%89%E5%87%BD%E6%95%B0/"/>
    <id>http://example.com/2021/10/10/scanf%EF%BC%88%EF%BC%89%E4%B8%8Escanf-s%EF%BC%88%EF%BC%89%E5%87%BD%E6%95%B0/</id>
    <published>2021-10-10T03:47:39.000Z</published>
    <updated>2021-10-10T03:47:39.202Z</updated>
    
    
    
    
    
  </entry>
  
  <entry>
    <title>hexo一些基本命令</title>
    <link href="http://example.com/2021/10/06/hexo%E4%B8%80%E4%BA%9B%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4/"/>
    <id>http://example.com/2021/10/06/hexo%E4%B8%80%E4%BA%9B%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4/</id>
    <published>2021-10-06T12:59:36.000Z</published>
    <updated>2021-10-06T14:38:38.634Z</updated>
    
    <content type="html"><![CDATA[<p>首先Ctrl+C停止当前的本地服务，然后</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo n &quot;我的第一篇文章&quot;</span><br></pre></td></tr></table></figure><p>这样便产生了一篇文章</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">文章需要使用Markdown语法进行编写</span><br></pre></td></tr></table></figure><p>hexo g #完整命令为hexo generate,用于生成静态文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo s #完整命令为hexo server,用于启动服务器，主要用来本地预览</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo d #完整命令为hexo deploy,用于将本地文件发布到github等git仓库上</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo n &quot;my article&quot; #完整命令为hexo new,用于新建一篇名为“my article”的文章</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;首先Ctrl+C停止当前的本地服务，然后&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>排序算法</title>
    <link href="http://example.com/2021/10/06/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
    <id>http://example.com/2021/10/06/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/</id>
    <published>2021-10-06T12:56:15.000Z</published>
    <updated>2021-10-10T08:55:20.133Z</updated>
    
    <content type="html"><![CDATA[<h1 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h1><p>冒泡排序是前后两两比较，满足条件则交换顺序，这种排序算法是稳定的，此篇以从小到大排序为例进行说明</p><ol><li>两两比较a[i]和a[i+1]，如果a[i]&gt;a[i+1]则交换两者位置</li><li>经过步骤1，最大的数已经排到最后，在对剩下的N-1个数字进行排序。</li></ol><p><strong>算法步骤示例：</strong><br><img src="/2021/10/06/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/001.gif" alt="冒泡排序"><br><strong>模板总结</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">void bubbleSort(int a[], int n)</span><br><span class="line">&#123;</span><br><span class="line">    for(int i &#x3D; n - 1; i &gt; 0; i--)</span><br><span class="line">        for(int j &#x3D; 0; j &lt; i; j++)</span><br><span class="line">            if(a[j] &gt; a[j+1]) </span><br><span class="line">                swap(a[j], a[j+1]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h1><p>快速排序是优化的冒泡排序，他的每次交换都是跳跃式的，这种排序是不稳定的。<br>依然亦从小到大为例，对下列数据进行排序<br><img src="/2021/10/06/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/002.png" alt="数字"><br>快速排序要首先在序列中找一个基准数，一第一个数为基准数较为方便（也可以是左边的数或者右边的数）<br><img src="/2021/10/06/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/003.png" alt="标记基准数"><br>我们的任务是找到这个数应该在的位置然后把他换过去。从右往左找小于6的数，从左往右找大于6的数，然后交换他们的位置<br>再将依次左边和右边分别排序,每次排序之后中间的数不一定是选取的数。</p><p>快速排序之所以比较快，是因为与冒泡排序相比，每次的交换时跳跃式的，每次排序的时候设置一个基准点，将小于等于基准点的数全部放到基准点的左边，将大于等于基准点的数全部放到基准点的右边。这样在每次交换的时候就不会像冒泡排序一样每次只能在相邻的数之间进行交换，交换的距离就大的多了。因此总的比较和交换次数就少了，速度自然就提高了。当然在最坏的情况下，仍可能是相邻的两个数进行了交换。因此快速排序的最差时间复杂度和冒泡排序是一样的都是 O ( n 2 ) O(n^2) O(n2)，它的平均时间复杂度为 O ( n log ⁡ 2 n ) O(n\log_2n) O(nlog2​n)。</p><p><strong>模板总结</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">void Quick_Sort(int *arr, int begin, int end)&#123;</span><br><span class="line">    if(begin &gt;&#x3D; end)</span><br><span class="line">        return;</span><br><span class="line">    int tmp &#x3D; arr[begin];</span><br><span class="line">    int i &#x3D; begin;</span><br><span class="line">    int j &#x3D; end;</span><br><span class="line">    while(i !&#x3D; j)&#123;</span><br><span class="line">        while(arr[j] &gt;&#x3D; tmp &amp;&amp; j &gt; i)</span><br><span class="line">            j--;</span><br><span class="line">        while(arr[i] &lt;&#x3D; tmp &amp;&amp; j &gt; i)</span><br><span class="line">            i++;</span><br><span class="line">        if(j &gt; i)&#123;</span><br><span class="line">            int t &#x3D; arr[i];</span><br><span class="line">            arr[i] &#x3D; arr[j];</span><br><span class="line">            arr[j] &#x3D; t;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    arr[begin] &#x3D; arr[i];</span><br><span class="line">    arr[i] &#x3D; tmp;</span><br><span class="line">    Quick_Sort(arr, begin, i-1);</span><br><span class="line">    Quick_Sort(arr, i+1, end);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h1><ol><li>排序思想：将初始序列的n个元素看成n个有序的子序列，每个子序列中只有一个元素，将其两两归并，得到n/2个长度为2(或1、子序列不为偶数则有落单)的有序子序列，再两两归并…以此类推直到得到n长的有序序列。</li><li>归并思想：两个子序列，分别有一个指针指向其首部，指针指向的元素进行对比，小的放入辅助数组里，指针后移，大的不动，直到两两对比完成，此时如果有某一子序列中的元素并没有对比完，则直接放入辅助数组。</li><li>优缺点：效率高且稳定，但是消耗的辅助空间与原数据空间成正比。</li><li>复杂度：时间复杂度O(nlogn) 空间复杂度O(n)</li><li>稳定性：稳定<br><img src="/2021/10/06/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/009.png" alt="图片"></li></ol><p><strong>代码如下：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**************************</span><br><span class="line"> 题目：归并排序</span><br><span class="line">划分成很小的组，然后两两归并</span><br><span class="line">***************************&#x2F;</span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">void Merge(int[], int, int[], int, int, int)  &#x2F;&#x2F;归并函数的声明【把归并函数提到该函数前面，则不用声明】</span><br><span class="line">&#x2F;&#x2F;归并排序</span><br><span class="line">&#x2F;&#x2F;参数：</span><br><span class="line">&#x2F;&#x2F;numbers[]：原数组</span><br><span class="line">&#x2F;&#x2F;length：数组元素的个数（数组长度）</span><br><span class="line">&#x2F;&#x2F;temp[]：辅助数组</span><br><span class="line">&#x2F;&#x2F;begin：数组开头的下标</span><br><span class="line">&#x2F;&#x2F;end：数组结尾的下标</span><br><span class="line">void MergeSort(int numbers[], int length, int temp[], int begin, int end)</span><br><span class="line">&#123;</span><br><span class="line">&#x2F;&#x2F;1. 同样判断传入的参数是否有效</span><br><span class="line">if (numbers &#x3D;&#x3D; nullptr || length &lt;&#x3D; 0 || begin &lt; 0 || end &gt;&#x3D; length)</span><br><span class="line">throw new exception(&quot;Invalid input.&quot;);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;2. 作为递归的结束条件，开始下标和结束下标相等时，说明子序列中只有一个元素，看作有序的</span><br><span class="line">if (end - begin &#x3D;&#x3D; 0)</span><br><span class="line">return;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;3. 定义中间变量，将数组分半【如果有7个元素，下标0-6，则middle&#x3D;3，数组分为长度为4和3的两段】</span><br><span class="line">int middle &#x3D; ((end - begin) &#x2F; 2 ) + begin;</span><br><span class="line">&#x2F;&#x2F;4. 递归，先递归左半边，再递归右半边，将左右子序列不断分为长度为1的子序列才停止递归</span><br><span class="line">MergeSort(numbers, length, temp, begin, middle);</span><br><span class="line">MergeSort(numbers, length, temp, middle + 1, end);</span><br><span class="line">&#x2F;&#x2F;5. 再慢慢归并</span><br><span class="line">Merge(numbers, length, temp, begin, end, middle);</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;归并函数</span><br><span class="line">&#x2F;&#x2F;参数：</span><br><span class="line">&#x2F;&#x2F;numbers[]：原数组</span><br><span class="line">&#x2F;&#x2F;length：数组元素的个数（数组长度）</span><br><span class="line">&#x2F;&#x2F;temp[]：辅助数组</span><br><span class="line">&#x2F;&#x2F;begin：数组开头的下标</span><br><span class="line">&#x2F;&#x2F;end：数组结尾的下标</span><br><span class="line">&#x2F;&#x2F;middle：数组中间的下标</span><br><span class="line">void Merge(int numbers[], int length, int temp[], int begin, int end, int middle)</span><br><span class="line">&#123;</span><br><span class="line">&#x2F;&#x2F;1. 判断是否有不符合要求的参数传入，有则抛出错误</span><br><span class="line">if (numbers &#x3D;&#x3D; nullptr || length &lt;&#x3D; 0 || begin &lt; 0 || end &gt;&#x3D; length)</span><br><span class="line">throw new exception(&quot;Invalid input.&quot;);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;2. 将原序列从中分开</span><br><span class="line">int leftIndex &#x3D; begin;&#x2F;&#x2F;左边序列的开始（左边序列的结尾是middle）</span><br><span class="line">int rightIndex &#x3D; middle + 1;&#x2F;&#x2F;右边序列的开始（右边序列的结尾是end）</span><br><span class="line">int tempIndex &#x3D; begin;&#x2F;&#x2F;辅助数组的下标</span><br><span class="line">&#x2F;&#x2F;3. 当左右子序列尚未到头时，循环</span><br><span class="line">while (leftIndex &lt;&#x3D; middle &amp;&amp; rightIndex &lt;&#x3D; end)</span><br><span class="line">&#123;</span><br><span class="line">&#x2F;&#x2F;4. 两两对比判断，谁大谁就放入辅助数组，同时指针后移</span><br><span class="line">if (numbers[leftIndex] &lt; numbers[rightIndex])</span><br><span class="line">temp[tempIndex] &#x3D; numbers[leftIndex++];</span><br><span class="line">else</span><br><span class="line">temp[tempIndex] &#x3D; numbers[rightIndex++];</span><br><span class="line">&#x2F;&#x2F;5. 辅助数组下标++</span><br><span class="line">++tempIndex;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;6. 当左边或右边子序列尚未到头时，直接放入辅助数组</span><br><span class="line">while (leftIndex &lt;&#x3D; middle)</span><br><span class="line">temp[tempIndex++] &#x3D; numbers[leftIndex++];</span><br><span class="line"></span><br><span class="line">while (rightIndex &lt;&#x3D; end)</span><br><span class="line">temp[tempIndex++] &#x3D; numbers[rightIndex++];</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;7. 再将辅助数组中已经有序的元素覆盖掉原数组中无序的元素，使原数组变成部分有序</span><br><span class="line">for (int i &#x3D; begin; i &lt;&#x3D; end; ++i)</span><br><span class="line">numbers[i] &#x3D; temp[i];</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;简单测试</span><br><span class="line">int main(int arvc, char* argv[])</span><br><span class="line">&#123;</span><br><span class="line">const int length &#x3D; 9;</span><br><span class="line">int nums[length] &#x3D; &#123; 18, 7, 23, 3, 9, 32, 10 , 99, 0&#125;;</span><br><span class="line">int *temp &#x3D; new int[length];</span><br><span class="line"></span><br><span class="line">MergeSort(nums, length, temp, 0, 8);</span><br><span class="line"></span><br><span class="line">for (int i &#x3D; 0; i &lt; length; i++)</span><br><span class="line">cout &lt;&lt; nums[i] &lt;&lt; &quot;  &quot;;</span><br><span class="line"></span><br><span class="line">delete[] temp;</span><br><span class="line">temp &#x3D; nullptr;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;冒泡排序&quot;&gt;&lt;a href=&quot;#冒泡排序&quot; class=&quot;headerlink&quot; title=&quot;冒泡排序&quot;&gt;&lt;/a&gt;冒泡排序&lt;/h1&gt;&lt;p&gt;冒泡排序是前后两两比较，满足条件则交换顺序，这种排序算法是稳定的，此篇以从小到大排序为例进行说明&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>助手函数</title>
    <link href="http://example.com/2021/04/11/%E5%8A%A9%E6%89%8B%E5%87%BD%E6%95%B0/"/>
    <id>http://example.com/2021/04/11/%E5%8A%A9%E6%89%8B%E5%87%BD%E6%95%B0/</id>
    <published>2021-04-11T07:41:35.000Z</published>
    <updated>2021-04-21T00:52:30.368Z</updated>
    
    <content type="html"><![CDATA[<p>str.find();<br>str.substr();<br>str.length();</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;str.find();&lt;br&gt;str.substr();&lt;br&gt;str.length();&lt;/p&gt;
</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>BUU15</title>
    <link href="http://example.com/2021/03/11/BUU15/"/>
    <id>http://example.com/2021/03/11/BUU15/</id>
    <published>2021-03-11T05:45:05.000Z</published>
    <updated>2021-03-11T08:39:53.255Z</updated>
    
    <content type="html"><![CDATA[<h1 id="RCTF2019-disk"><a href="#RCTF2019-disk" class="headerlink" title="[RCTF2019]disk"></a><strong>[RCTF2019]disk</strong></h1><p>题目设定：</p><blockquote><p>  An otaku used VeraCrypt to encrypt his favorites.<br>    Password: rctf<br>    Flag format: rctf{a-zA-Z0-9_}<br>首先下载题目附件，得到rctf-disk.zip，解压得到encrypt.vmdk。<br>因为无法确定vmdk是VeraCrypt加密完的虚拟硬盘文件随便改了个格式，<br>还是存储了VeraCrypt加密后虚拟磁盘文件的虚拟磁盘，因此先尝试使用7zip打开该文件。<br><img src="/2021/03/11/BUU15/1.png"><br>说明外层的vmdk只是容器，并没有加密。将0.fat解压出来，再次尝试用7zip打开，报错，说明vmdk中包含的这个FAT32分区被加密了。使用WinHex载入这个文件可以看到：<br><img src="/2021/03/11/BUU15/2.png"><br>这样我们就得到了前半段Flag，为： <code>rctf&#123;unseCure_quick_form4t_vo1ume</code><br>使用题目中所给的VeraCrypt密码对0.fat文件进行解密并加载，发现加载成功，为常规卷，加密类型为AES。<br><img src="/2021/03/11/BUU15/6.png"><br>注意左侧文件的文件名70056639_useless_file_for_ctf_just_ignore_it.jpg，说明其不包含解题的有效信息。于是打开password.txt，文件内容为：</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Password 2: RCTF2019</span><br><span class="line">You&#39;re late... So sad</span><br></pre></td></tr></table></figure><p><img src="/2021/03/11/BUU15/3.png"><br>将此加密盘卸载，使用得到的第二个密码再次加载，加载成功。加密方式是AES，但是注意该分区是隐藏分区。<br><img src="/2021/03/11/BUU15/4.png"><br>由于是隐藏分区所以无法直接访问。因此使用WinHex载入磁盘，提示无法自动检测分区格式后选择“分区无格式”，并查看该分区扇区数据（DiskGenius查看磁盘扇区数据也可以）。<br><img src="/2021/03/11/BUU15/5.png"><br>得到后半段Flag：<code>_and_corrupted__1nner_v0lume&#125;</code><br>拼接后得到完整的Flag：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rctf&#123;unseCure_quick_form4t_vo1ume_and_corrupted_1nner_v0lume&#125;</span><br></pre></td></tr></table></figure><hr><hr><hr><h1 id="watevrCTF-2019-Evil-Cuteness"><a href="#watevrCTF-2019-Evil-Cuteness" class="headerlink" title="[watevrCTF 2019]Evil Cuteness"></a><strong>[watevrCTF 2019]Evil Cuteness</strong></h1><p>binwalk分离打开出来的abc<br>得到flag<br><img src="/2021/03/11/BUU15/7.png"></p><hr><hr><hr><h1 id="取证-HDCTF2019-你能发现什么蛛丝马迹吗"><a href="#取证-HDCTF2019-你能发现什么蛛丝马迹吗" class="headerlink" title="取证 [HDCTF2019]你能发现什么蛛丝马迹吗"></a><strong>取证 [HDCTF2019]你能发现什么蛛丝马迹吗</strong></h1><p>打开文件<br>flag白给</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># Challenge description:</span><br><span class="line"></span><br><span class="line">I really hope you are INSAne, but if that&#39;s not the case and that you don&#39;t want to validate the &quot;INSAnity&quot; challenge then maybe you would like to validate this one? Here is your flag, you disapointing and boring fellow: INSA&#123;Youre_sane_Good_for_you&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flag&#123;Youre_sane_Good_for_you&#125;</span><br></pre></td></tr></table></figure><h1 id="很好的色彩呃？"><a href="#很好的色彩呃？" class="headerlink" title="很好的色彩呃？"></a><strong>很好的色彩呃？</strong></h1><p>根据题目和图片，图片的颜色十六进制号可能是flag的十六进制编码，<br>有两种办法:<br>1.用 <code>qq截屏</code> 时，按住<code>ctrl</code>和<code>c</code><br><img src="/2021/03/11/BUU15/8.png"><br>2.用ps<br><img src="/2021/03/11/BUU15/9.png"><br>得到十六进制字符</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">6161706a6573</span><br></pre></td></tr></table></figure><p>解ascii码得到flag</p><hr><hr><hr><h1 id="GUET-CTF2019-520的暗示"><a href="#GUET-CTF2019-520的暗示" class="headerlink" title="[GUET-CTF2019]520的暗示"></a><strong>[GUET-CTF2019]520的暗示</strong></h1><p>十六进制打开dat文件<br>看起来像33异或运算<br><img src="/2021/03/11/BUU15/10.png"><br>得到一张图片<br><img src="/2021/03/11/BUU15/11.png"><br>不会搞了<br><img src="/2021/03/11/BUU15/12.png"><br> 后面其实是根据LTE定位基站地址，最后定位到桂林电子科技大学花江校区，也就是flag为flag{桂林电子科技大学花江校区}。<br>地址： <a href="https://www.opengps.cn/Data/Cell/Search.aspx">https://www.opengps.cn/Data/Cell/Search.aspx</a></p><hr><hr><hr><h1 id="key不在这里"><a href="#key不在这里" class="headerlink" title="key不在这里"></a><strong>key不在这里</strong></h1><p>扫二维码是个链接<br>有一大坨数字<br><img src="/2021/03/11/BUU15/13.png"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">10210897103375566531005253102975053545155505050521025256555254995410298561015151985150375568</span><br></pre></td></tr></table></figure><p> 直接ascii码转</p><p><img src="/2021/03/11/BUU15/14.png"><br>转url得到flag<br><img src="/2021/03/11/BUU15/15.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;RCTF2019-disk&quot;&gt;&lt;a href=&quot;#RCTF2019-disk&quot; class=&quot;headerlink&quot; title=&quot;[RCTF2019]disk&quot;&gt;&lt;/a&gt;&lt;strong&gt;[RCTF2019]disk&lt;/strong&gt;&lt;/h1&gt;&lt;p&gt;题目设定：&lt;/</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>BUU流量分析1</title>
    <link href="http://example.com/2021/03/10/BUU%E6%B5%81%E9%87%8F%E5%88%86%E6%9E%901/"/>
    <id>http://example.com/2021/03/10/BUU%E6%B5%81%E9%87%8F%E5%88%86%E6%9E%901/</id>
    <published>2021-03-10T06:00:50.000Z</published>
    <updated>2021-03-13T15:25:15.563Z</updated>
    
    <content type="html"><![CDATA[<h1 id="菜刀666"><a href="#菜刀666" class="headerlink" title="菜刀666"></a><strong>菜刀666</strong></h1><p>菜刀一般都是POST上传</p><p>所以我们直接过滤出POST数据包</p><p>http.request.method==POST</p><p>在tcp.stream eq 7中发现了大量数据<br><img src="/2021/03/10/BUU%E6%B5%81%E9%87%8F%E5%88%86%E6%9E%901/1.png"><br> FF D8开头FF D9结尾，判断为jpg图片，将这些十六进制复制出来，以原始文件流写入文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">#Author: MoChu7</span><br><span class="line">import struct</span><br><span class="line"></span><br><span class="line">a &#x3D; open(&quot;str.txt&quot;,&quot;r&quot;)#十六进制数据文件</span><br><span class="line">lines &#x3D; a.read()</span><br><span class="line">res &#x3D; [lines[i:i+2] for i in range(0,len(lines),2)]</span><br><span class="line"></span><br><span class="line">with open(&quot;res.jpg&quot;,&quot;wb&quot;) as f:</span><br><span class="line">for i in res:</span><br><span class="line">s &#x3D; struct.pack(&#39;B&#39;,int(i,16))</span><br><span class="line">f.write(s)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>脚本2</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">s&#x3D;&#39;填写16进制数据&#39;</span><br><span class="line">import binascii</span><br><span class="line">out&#x3D;open(&#39;2.jpg&#39;,&#39;wb&#39;)</span><br><span class="line">out.write(binascii.unhexlify(s))</span><br><span class="line">out.close()</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="/2021/03/10/BUU%E6%B5%81%E9%87%8F%E5%88%86%E6%9E%901/2.png"><br>在这个流中还发现了传输了一个hello.zip<br><img src="/2021/03/10/BUU%E6%B5%81%E9%87%8F%E5%88%86%E6%9E%901/3.png"></p><p> foremost分离流量包，得到一个zip，输入上面图片上的密码<br>解压得到flag</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flag&#123;3OpWdJ-JP6FzK-koCMAK-VkfWBq-75Un2z&#125;</span><br></pre></td></tr></table></figure><hr><hr><hr><h1 id="被偷走的文件"><a href="#被偷走的文件" class="headerlink" title="被偷走的文件"></a><strong>被偷走的文件</strong></h1><p> 传输文件看到了ftp协议，过滤，追踪，</p><p><img src="/2021/03/10/BUU%E6%B5%81%E9%87%8F%E5%88%86%E6%9E%901/4.png"><br>看到了压缩包，foremost分离</p><p><img src="/2021/03/10/BUU%E6%B5%81%E9%87%8F%E5%88%86%E6%9E%901/5.png"></p><p>数字暴力破解得到flag<br><img src="/2021/03/10/BUU%E6%B5%81%E9%87%8F%E5%88%86%E6%9E%901/6.png"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flag&#123;6fe99a5d03fb01f833ec3caa80358fa3&#125;</span><br></pre></td></tr></table></figure><h1 id="秘密文件"><a href="#秘密文件" class="headerlink" title="秘密文件"></a><strong>秘密文件</strong></h1><p>binwalk 分离得到一个压缩包<br><img src="/2021/03/10/BUU%E6%B5%81%E9%87%8F%E5%88%86%E6%9E%901/7.png"><br>暴力破解得到密码1903<br><img src="/2021/03/10/BUU%E6%B5%81%E9%87%8F%E5%88%86%E6%9E%901/8.png"><br>得到flag</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flag&#123;d72e5a671aa50fa5f400e5d10eedeaa5&#125;</span><br></pre></td></tr></table></figure><hr><hr><hr><h1 id="sqltest"><a href="#sqltest" class="headerlink" title="sqltest"></a><strong>sqltest</strong></h1><p>是个流量包,拖进wireshark里,发现有很多盲注痕迹<br>常规操作,导出HTTP进行分析,save all后在文件夹里进行排序<br><img src="/2021/03/10/BUU%E6%B5%81%E9%87%8F%E5%88%86%E6%9E%901/9.png"><br>当盲注结果为true时文件大小都是780b,经过文件内容的对比,发现都有Version被注出,根据条件找到有flag信息的盲注点,按名称和文件大小的排序提取ascil值<br><img src="/2021/03/10/BUU%E6%B5%81%E9%87%8F%E5%88%86%E6%9E%901/10.png"><br>转换后:flag{47edb8300ed5f9b28fc54b0d09ecdef7}</p><hr><hr><hr><h1 id="john-in-the-middle"><a href="#john-in-the-middle" class="headerlink" title="john-in-the-middle"></a><strong>john-in-the-middle</strong></h1><p> 可以看到都是HTTP的数据包，导出HTTP得到如下：<br><img src="/2021/03/10/BUU%E6%B5%81%E9%87%8F%E5%88%86%E6%9E%901/11.png"><br>看文件的名字仿佛是一个线索<br><img src="/2021/03/10/BUU%E6%B5%81%E9%87%8F%E5%88%86%E6%9E%901/13.png"><br>使用stegslove打开scanlines.png，在很多通道都发现了一条线<br><img src="/2021/03/10/BUU%E6%B5%81%E9%87%8F%E5%88%86%E6%9E%901/14.png"><br> 然后发现logo.png图片中貌似有条缺口<br><img src="/2021/03/10/BUU%E6%B5%81%E9%87%8F%E5%88%86%E6%9E%901/15.png"><br> 将两张图片使用stegslove进行Image Combiner进行对比<br><img src="/2021/03/10/BUU%E6%B5%81%E9%87%8F%E5%88%86%E6%9E%901/16.png"><br> 调整到SUB时发现flag</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flag&#123;J0hn_th3_Sn1ff3r&#125;</span><br></pre></td></tr></table></figure><h1 id="V-amp-N2020-公开赛-拉胯的三条命令"><a href="#V-amp-N2020-公开赛-拉胯的三条命令" class="headerlink" title="[V&amp;N2020 公开赛]拉胯的三条命令"></a><strong>[V&amp;N2020 公开赛]拉胯的三条命令</strong></h1><p> 题目文件zip</p><p><img src="/2021/03/10/BUU%E6%B5%81%E9%87%8F%E5%88%86%E6%9E%901/17.png"><br> zip文件，添加后缀zip<br><img src="/2021/03/10/BUU%E6%B5%81%E9%87%8F%E5%88%86%E6%9E%901/18.png"><br> 说明.txt</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">在参加网络安全大赛第二届世界巡回赛新加坡站一场与SP战队的比赛时，作为K&amp;K战队主防手的你使用经典的“三条命令”检查端口封闭状况。可是这次比赛平台没有回显，你能查出来有哪些端口是开放的嘛？</span><br><span class="line">请将开放端口按由小到大顺序写入flag中 如：开放1、22、234端口，flag&#123;122234&#125;</span><br></pre></td></tr></table></figure><p>wireshark打开nmapll.pcapng，在编辑-&gt;首选项-&gt;外观-&gt;列添加一个Port类型选择Dest port(unresolved)<br><img src="/2021/03/10/BUU%E6%B5%81%E9%87%8F%E5%88%86%E6%9E%901/19.png"><br> 以port列降序排序，查找每个端口是否有[ACK]响应标志，众所周知在TCP三次握手中，[SYN]标志表示建立连接，[ACK]表示响应，查看开放端口，肯定会返回[ACK]标志<br><img src="/2021/03/10/BUU%E6%B5%81%E9%87%8F%E5%88%86%E6%9E%901/20.png"><br> 这样手工找下去可以得到开放的端口有</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1.21</span><br><span class="line">127.0.0.1.22</span><br><span class="line">127.0.0.1.631</span><br><span class="line">127.0.0.1.801</span><br><span class="line">127.0.0.1.3306</span><br></pre></td></tr></table></figure><p>也可以使用工具Tcpdump</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tcpdump -n -r nmapll.pcapng &#39;tcp[13] &#x3D; 18&#39; | awk &#39;&#123;print $3&#125;&#39; | sort -u</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">root@mochu7:&#x2F;mnt&#x2F;c&#x2F;Users&#x2F;Administrator&#x2F;Downloads&#x2F;zip1# tcpdump -n -r nmapll.pcapng &#39;tcp[13] &#x3D; 18&#39; | awk &#39;&#123;print $3&#125;&#39; | sort -u</span><br><span class="line">reading from file nmapll.pcapng, link-type EN10MB (Ethernet)</span><br><span class="line">127.0.0.1.21</span><br><span class="line">127.0.0.1.22</span><br><span class="line">127.0.0.1.3306</span><br><span class="line">127.0.0.1.631</span><br><span class="line">127.0.0.1.801</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flag&#123;21226318013306&#125;</span><br></pre></td></tr></table></figure><h1 id="ACTF新生赛2020-swp"><a href="#ACTF新生赛2020-swp" class="headerlink" title="[ACTF新生赛2020]swp"></a><strong>[ACTF新生赛2020]swp</strong></h1><p>解压后在wget.zip中发现个数据包，解压后用wireshark打开，看着像http数据传输</p><p>导出http<br><img src="/2021/03/10/BUU%E6%B5%81%E9%87%8F%E5%88%86%E6%9E%901/21.png"><br>在导出的文件中发现一个secret.zip<br><img src="/2021/03/10/BUU%E6%B5%81%E9%87%8F%E5%88%86%E6%9E%901/22.png"><br>打开得到flag<br><img src="/2021/03/10/BUU%E6%B5%81%E9%87%8F%E5%88%86%E6%9E%901/23.png"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">actf&#123;c5558bcf-26da-4f8b-b181-b61f3850b9e5&#125;</span><br></pre></td></tr></table></figure><h1 id="百里挑一"><a href="#百里挑一" class="headerlink" title="百里挑一"></a><strong>百里挑一</strong></h1><p>解压文件得到的是pcap数据包，题目提示好多图片，<br>wireshark打开导出http对象，保存到一个文件夹中。然后在kali中使用一条命令找到一半的flag<br><img src="/2021/03/10/BUU%E6%B5%81%E9%87%8F%E5%88%86%E6%9E%901/24.png"><br> 另一半需要在wireshark中找, 看了wp发现是114……郁闷💔<br><img src="/2021/03/10/BUU%E6%B5%81%E9%87%8F%E5%88%86%E6%9E%901/25.png"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flag&#123;ae58d0408e26e8f26a3c0589d23edeec&#125;</span><br></pre></td></tr></table></figure><h1 id="安洵杯-2019-Attack"><a href="#安洵杯-2019-Attack" class="headerlink" title="[安洵杯 2019]Attack"></a><strong>[安洵杯 2019]Attack</strong></h1><p>流量分析题，学到了一个新工具mimikatz</p><blockquote><p>mimikatz 在内网渗透中是个很有用的工具。它可能让攻击者从内存中抓到明文密码。</p></blockquote><p><strong>考点:</strong></p><ol><li>数据包流量分析</li><li>蚁剑流量特征</li><li>procdump的使用</li></ol><p><strong>题解：</strong><br>使用wireshark打开数据包，简单看一下应该是进行了扫目录操作：<br><img src="/2021/03/10/BUU%E6%B5%81%E9%87%8F%E5%88%86%E6%9E%901/26.png"><br>然后对TCP流进行分析，发现一处对upload.php的POST请求：<br><img src="/2021/03/10/BUU%E6%B5%81%E9%87%8F%E5%88%86%E6%9E%901/27.png"><br>然后追踪TCP流，发现上传了一句话木马：<br><img src="/2021/03/10/BUU%E6%B5%81%E9%87%8F%E5%88%86%E6%9E%901/28.png"><br>接着往下分析，发现一组TCP流量疑似执行了命令，请求流量经过了base64混淆，返回流量用了ROT13<br><img src="/2021/03/10/BUU%E6%B5%81%E9%87%8F%E5%88%86%E6%9E%901/29.png"><br>继续跟TCP流发现列目录列出来了一个s3cret.zip<br><img src="/2021/03/10/BUU%E6%B5%81%E9%87%8F%E5%88%86%E6%9E%901/30.png"><br>下一组流量中出现了一组看起来是zip的数据：<br><img src="/2021/03/10/BUU%E6%B5%81%E9%87%8F%E5%88%86%E6%9E%901/31.png"><br>查看hex数据发现50 4B 03 04的zip文件头，将其拿出来导入到010editor中保存为zip：<br><img src="/2021/03/10/BUU%E6%B5%81%E9%87%8F%E5%88%86%E6%9E%901/32.png"><br>但是发现需要解压密码，打开发现hint<br><img src="/2021/03/10/BUU%E6%B5%81%E9%87%8F%E5%88%86%E6%9E%901/33.png"><br>然后可以得到意思是解压密码为administrator的密码，于是继续回去看流量，发现执行了procdump.exe这个工具<br><img src="/2021/03/10/BUU%E6%B5%81%E9%87%8F%E5%88%86%E6%9E%901/34.png"><br>如果不熟悉的这个工具话可以使用搜索引擎得知该工具一般用来抓取windows的lsass进程中的用户明文密码</p><p>紧接着发现攻击者通过http下载了lsass.dmp文件<br><img src="/2021/03/10/BUU%E6%B5%81%E9%87%8F%E5%88%86%E6%9E%901/35.png"><br>我们将该文件导出，然后导入mimikatz即可得到administrator的密码<br><img src="/2021/03/10/BUU%E6%B5%81%E9%87%8F%E5%88%86%E6%9E%901/36.png"><br>之后再拿过去解压就得到flag<br><img src="/2021/03/10/BUU%E6%B5%81%E9%87%8F%E5%88%86%E6%9E%901/37.png"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Flag：D0g3&#123;3466b11de8894198af3636c5bd1efce2&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;菜刀666&quot;&gt;&lt;a href=&quot;#菜刀666&quot; class=&quot;headerlink&quot; title=&quot;菜刀666&quot;&gt;&lt;/a&gt;&lt;strong&gt;菜刀666&lt;/strong&gt;&lt;/h1&gt;&lt;p&gt;菜刀一般都是POST上传&lt;/p&gt;
&lt;p&gt;所以我们直接过滤出POST数据包&lt;/p&gt;
</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>BUU14</title>
    <link href="http://example.com/2021/03/10/BUU14/"/>
    <id>http://example.com/2021/03/10/BUU14/</id>
    <published>2021-03-10T00:39:09.000Z</published>
    <updated>2021-03-10T05:09:27.092Z</updated>
    
    <content type="html"><![CDATA[<h1 id="GWCTF2019-huyao"><a href="#GWCTF2019-huyao" class="headerlink" title="[GWCTF2019]huyao"></a><strong>[GWCTF2019]huyao</strong></h1><p>下载得到两个肉眼看着一样的图片 盲猜盲水印<br>用github上那个最常见的脚本和stegsolve没用<br>用1的脚本</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python decode.py --original huyao.png --image stillhuyao.png --result res.png</span><br></pre></td></tr></table></figure><p><img src="/2021/03/10/BUU14/1.png"></p><h1 id="GUET-CTF2019-soul-sipse"><a href="#GUET-CTF2019-soul-sipse" class="headerlink" title="[GUET-CTF2019]soul sipse"></a><strong>[GUET-CTF2019]soul sipse</strong></h1><p>这里是音频隐写，用steghide解密<br><img src="/2021/03/10/BUU14/2.png"><br>修改下载得到的png文件头，使其可以打开<br><img src="/2021/03/10/BUU14/3.png"><br>Unicode编码<br><img src="/2021/03/10/BUU14/4.png"><br>解出来两个数字<br><img src="/2021/03/10/BUU14/5.png"><br>相加即为flag<br><img src="/2021/03/10/BUU14/6.png"></p><hr><hr><hr><h1 id="UTCTF2020-sstv"><a href="#UTCTF2020-sstv" class="headerlink" title="[UTCTF2020]sstv"></a><strong>[UTCTF2020]sstv</strong></h1><p><strong>慢扫描电视（SSTV）</strong></p><p>慢扫描电视（Slow-scan television）是业余无线电爱好者的一种主要图片传输方法，慢扫描电视通过无线电传输和接收单色或彩色静态图片。<br><img src="/2021/03/10/BUU14/8.png"><br>使用QSSTV将慢速扫描电视传输(SSTV)音频文件转换(解码)为图像<br><img src="/2021/03/10/BUU14/7.png"></p><hr><hr><hr><h1 id="UTCTF2020-spectogram"><a href="#UTCTF2020-spectogram" class="headerlink" title="[UTCTF2020]spectogram"></a><strong>[UTCTF2020]spectogram</strong></h1><p>用Audacity打开wav，看频谱图。<br><img src="/2021/03/10/BUU14/9.png"></p><hr><hr><hr><h1 id="UTCTF2020-File-Carving"><a href="#UTCTF2020-File-Carving" class="headerlink" title="[UTCTF2020]File Carving"></a><strong>[UTCTF2020]File Carving</strong></h1><p>foremost分离后得到一个压缩包<br>运行压缩包中hidden_binary得到flag</p><p><img src="/2021/03/10/BUU14/10.png"><br>（strings命令也可得到）</p><hr><hr><hr><h1 id="python-我爱Linux"><a href="#python-我爱Linux" class="headerlink" title="python 我爱Linux"></a><strong>python 我爱Linux</strong></h1><p>Python Picke序列化内容<br>然后打印坐标</p><hr><hr><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;GWCTF2019-huyao&quot;&gt;&lt;a href=&quot;#GWCTF2019-huyao&quot; class=&quot;headerlink&quot; title=&quot;[GWCTF2019]huyao&quot;&gt;&lt;/a&gt;&lt;strong&gt;[GWCTF2019]huyao&lt;/strong&gt;&lt;/h1&gt;&lt;p</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>BUU13</title>
    <link href="http://example.com/2021/03/09/BUU13/"/>
    <id>http://example.com/2021/03/09/BUU13/</id>
    <published>2021-03-09T03:33:45.000Z</published>
    <updated>2021-03-10T00:38:24.861Z</updated>
    
    <content type="html"><![CDATA[<h1 id="wireshark-voip"><a href="#wireshark-voip" class="headerlink" title="wireshark voip"></a><strong>wireshark voip</strong></h1><hr><hr><hr><h1 id="UTCTF2020-zero"><a href="#UTCTF2020-zero" class="headerlink" title="[UTCTF2020]zero"></a><strong>[UTCTF2020]zero</strong></h1><p>一个文本文件 刚开始以为类似凯撒之类的 ，用自己写的脚本跑出来奇奇怪怪的结果<br>放cyberchef 贴进去就可以看到很多点 猜测零宽字节<br><img src="/2021/03/09/BUU13/2.png"><br>应该是零字节解密： <a href="http://330k.github.io/misc_tools/unicode_steganography.html">http://330k.github.io/misc_tools/unicode_steganography.html</a><br><img src="/2021/03/09/BUU13/3.png"><br>得到flag</p><hr><hr><hr><h1 id="QCTF2018-X-man-A-face"><a href="#QCTF2018-X-man-A-face" class="headerlink" title="[QCTF2018]X-man-A face"></a><strong>[QCTF2018]X-man-A face</strong></h1><p>补全二维码得到一串base32字符<br><img src="/2021/03/09/BUU13/3.png"><br>解码得到flag<br><img src="/2021/03/09/BUU13/4.png"></p><hr><hr><hr><h1 id="Business-Planning-Group"><a href="#Business-Planning-Group" class="headerlink" title="Business Planning Group"></a><strong>Business Planning Group</strong></h1><p>winhex打开在结尾找到bpg图片<br><img src="/2021/03/09/BUU13/5.png"><br>在网上搜了一下，这种bpg图片可以用Honeyview打开<br><img src="/2021/03/09/BUU13/6.png"><br>解码base64得到flag</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flag&#123;BPG_i5_b3tt3r_7h4n_JPG&#125;</span><br></pre></td></tr></table></figure><hr><hr><hr><h1 id="ACTF新生赛2020-剑龙"><a href="#ACTF新生赛2020-剑龙" class="headerlink" title="[ACTF新生赛2020]剑龙"></a><strong>[ACTF新生赛2020]剑龙</strong></h1><p>打开后发现有一个hint<br><img src="/2021/03/09/BUU13/7.png"><br>先将pwd解密<br><img src="/2021/03/09/BUU13/8.png"><br>steghide将图片解密<br><img src="/2021/03/09/BUU13/9.png"><br>des加密，密钥藏在属性里<br><img src="/2021/03/09/BUU13/10.png"><br>揭秘得到要用stegsaurus<br><img src="/2021/03/09/BUU13/11.png"><br>这里搞不出来了<br><img src="/2021/03/09/BUU13/12.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;wireshark-voip&quot;&gt;&lt;a href=&quot;#wireshark-voip&quot; class=&quot;headerlink&quot; title=&quot;wireshark voip&quot;&gt;&lt;/a&gt;&lt;strong&gt;wireshark voip&lt;/strong&gt;&lt;/h1&gt;&lt;hr&gt;
&lt;hr</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>2020上海大学生网络安全赛MISC可乐加冰</title>
    <link href="http://example.com/2021/03/08/2020%E4%B8%8A%E6%B5%B7%E5%A4%A7%E5%AD%A6%E7%94%9F%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E8%B5%9BMISC%E5%8F%AF%E4%B9%90%E5%8A%A0%E5%86%B0/"/>
    <id>http://example.com/2021/03/08/2020%E4%B8%8A%E6%B5%B7%E5%A4%A7%E5%AD%A6%E7%94%9F%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E8%B5%9BMISC%E5%8F%AF%E4%B9%90%E5%8A%A0%E5%86%B0/</id>
    <published>2021-03-08T04:53:47.000Z</published>
    <updated>2021-03-08T05:19:05.513Z</updated>
    
    <content type="html"><![CDATA[<p>题目附件是一张PNG图片：<br><img src="/2021/03/08/2020%E4%B8%8A%E6%B5%B7%E5%A4%A7%E5%AD%A6%E7%94%9F%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E8%B5%9BMISC%E5%8F%AF%E4%B9%90%E5%8A%A0%E5%86%B0/1.png"><br> 丢到tweakpng里检测一下，发现两个报错：<br><img src="/2021/03/08/2020%E4%B8%8A%E6%B5%B7%E5%A4%A7%E5%AD%A6%E7%94%9F%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E8%B5%9BMISC%E5%8F%AF%E4%B9%90%E5%8A%A0%E5%86%B0/2.png"><br><img src="/2021/03/08/2020%E4%B8%8A%E6%B5%B7%E5%A4%A7%E5%AD%A6%E7%94%9F%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E8%B5%9BMISC%E5%8F%AF%E4%B9%90%E5%8A%A0%E5%86%B0/3.png"><br><img src="/2021/03/08/2020%E4%B8%8A%E6%B5%B7%E5%A4%A7%E5%AD%A6%E7%94%9F%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E8%B5%9BMISC%E5%8F%AF%E4%B9%90%E5%8A%A0%E5%86%B0/4.png"><br> 分析发现三个IDAT块是没问题的，但是多出了一个无法识别的DATx块，而且没有识别出结尾块IEND，放进Winhex里查看也证实了这一点。<br><img src="/2021/03/08/2020%E4%B8%8A%E6%B5%B7%E5%A4%A7%E5%AD%A6%E7%94%9F%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E8%B5%9BMISC%E5%8F%AF%E4%B9%90%E5%8A%A0%E5%86%B0/5.png"><br>在Winhex中看出文件尾是不完整的，正常的文件尾应该是 0000 49454E44 AE426082</p><p>结合之前tweakpng里的报错：Incorrect crc for DATx chunk (is 9c4e1c00,should be 886b1f6d)，即DATx块的CRC校验码不正确，断定DATx中存在大问题。</p><p>（PS：注意一下这里tweakpng提示的CRC校验码不正确是因为DATx里藏了zlib把结尾的CRC校验码覆盖了，不要试着改回去，不然就把路走窄了，别问我怎么知道的！）<br>binwalk跑一下发现存在zlib：<br><img src="/2021/03/08/2020%E4%B8%8A%E6%B5%B7%E5%A4%A7%E5%AD%A6%E7%94%9F%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E8%B5%9BMISC%E5%8F%AF%E4%B9%90%E5%8A%A0%E5%86%B0/6.png"><br> 在DATx块开头的地方也找到了zlib的文件头：<br><img src="/2021/03/08/2020%E4%B8%8A%E6%B5%B7%E5%A4%A7%E5%AD%A6%E7%94%9F%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E8%B5%9BMISC%E5%8F%AF%E4%B9%90%E5%8A%A0%E5%86%B0/15.png"><br>（这里选zlib一直选到文件尾也是可以的，解出来的字符串是一样的）</p><p>右键-&gt;Edit-&gt;CopyBlock-&gt;HexValues把16进制数值复制出来用Python脚本解压缩：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">import zlib</span><br><span class="line">import binascii</span><br><span class="line"></span><br><span class="line">#Winhex提取的十六进制zlib数据</span><br><span class="line">data &#x3D;&quot;789C558EC111C02008049B72AE012736660DDBAF0449800FC7B8B0B89724E65E0259005EDFDE48441BD01CCFF0878BB958B1C38FA9F4532555091F2269C8BABAFEAD6B9B843C6EE000679C4E1C00&quot;</span><br><span class="line"></span><br><span class="line">#默认将十六进制作为字符串解码，会出现错误，要将十六进制转换成字节码</span><br><span class="line">data1 &#x3D; bytes.fromhex(data)#十六进制转字节码</span><br><span class="line">#print(data1)</span><br><span class="line"></span><br><span class="line">data2 &#x3D; zlib.decompress(data1)#zlib解压字节码</span><br><span class="line">#print(data2)</span><br><span class="line"></span><br><span class="line">data3 &#x3D; binascii.hexlify(data2)#字节码转十六进制</span><br><span class="line">print(data3)</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>跑出来一串纯数字的字符串：<br>b’834636363695438346369595364383469595954383469595364383463636363643834636363695438346369595364383469595364334453443834636953636438346369536954383463636953643834636369543344534438346369595438346369536954383463636363643834636363643344534438346369595364383463695953643834636369543834695363643344534438346363695364383463695369543834636369536438346369595954383469595364383469536954383463636363643834636953643834636369543834695369543834636959543834636369536’</p><p>每两位作一个十进制数，将字符串转为Ascii码（此处经大佬点化）</p><p>Python脚本每两位加空格：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">import re</span><br><span class="line"></span><br><span class="line">data &#x3D; &quot;834636363695438346369595364383469595954383469595364383463636363643834636363695438346369595364383469595364334453443834636953636438346369536954383463636953643834636369543344534438346369595438346369536954383463636363643834636363643344534438346369595364383463695953643834636369543834695363643344534438346363695364383463695369543834636369536438346369595954383469595364383469536954383463636363643834636953643834636369543834695369543834636959543834636369536&quot;</span><br><span class="line">data_list &#x3D; re.findall(&quot;.&#123;2&#125;&quot;,data)</span><br><span class="line">data1 &#x3D; &quot; &quot;.join(data_list)</span><br><span class="line"></span><br><span class="line">print(data1)</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>十进制转Ascii码+删除空格：（<a href="http://www.ab126.com/goju/1711.html%EF%BC%89">http://www.ab126.com/goju/1711.html）</a></p><p><img src="/2021/03/08/2020%E4%B8%8A%E6%B5%B7%E5%A4%A7%E5%AD%A6%E7%94%9F%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E8%B5%9BMISC%E5%8F%AF%E4%B9%90%E5%8A%A0%E5%86%B0/7.png"><br>转换后：</p><p><img src="/2021/03/08/2020%E4%B8%8A%E6%B5%B7%E5%A4%A7%E5%AD%A6%E7%94%9F%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E8%B5%9BMISC%E5%8F%AF%E4%B9%90%E5%8A%A0%E5%86%B0/8.png"><br> 将S转为$:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">str &#x3D; &#39;S.$$$_+S.$__$+S.___+S.__$+S.$$$$+S.$$$_+S.$__$+S.__$+&quot;-&quot;+S.$_$$+S.$_$_+S.$$_$+S.$$_+&quot;-&quot;+S.$__+S.$_$_+S.$$$$+S.$$$+&quot;-&quot;+S.$__$+S.$__$+S.$$_+S._$$+&quot;-&quot;+S.$$_$+S.$_$_+S.$$_$+S.$___+S.__$+S._$_+S.$$$$+S.$_$+S.$$_+S._$_+S.$__+S.$$_$&#39;;</span><br><span class="line"></span><br><span class="line">str1 &#x3D; str.replace(&#39;S&#39;, &#39;$&#39;);</span><br><span class="line"></span><br><span class="line">print(str1)</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>转换后：<br><img src="/2021/03/08/2020%E4%B8%8A%E6%B5%B7%E5%A4%A7%E5%AD%A6%E7%94%9F%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E8%B5%9BMISC%E5%8F%AF%E4%B9%90%E5%8A%A0%E5%86%B0/9.png"><br>得到一串JJEncod码。<br>这里贴一点我对JJEncode的理解：<br>先看别处拿来的解释：</p><p><img src="/2021/03/08/2020%E4%B8%8A%E6%B5%B7%E5%A4%A7%E5%AD%A6%E7%94%9F%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E8%B5%9BMISC%E5%8F%AF%E4%B9%90%E5%8A%A0%E5%86%B0/10.png"><br>亲自尝试后发现这个JJEncode加密之后有一个外壳（就是你加密的JavaScript的代码，这里是alert(“”);）<br>（<a href="http://www.atoolbox.net/Tool.php?Id=704%EF%BC%89">http://www.atoolbox.net/Tool.php?Id=704）</a></p><p><img src="/2021/03/08/2020%E4%B8%8A%E6%B5%B7%E5%A4%A7%E5%AD%A6%E7%94%9F%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E8%B5%9BMISC%E5%8F%AF%E4%B9%90%E5%8A%A0%E5%86%B0/11.png"><br> 综上，解出来的JJEncode是里面那一串（相当于555），所以构造一个外壳之后是这样的：<br><img src="/2021/03/08/2020%E4%B8%8A%E6%B5%B7%E5%A4%A7%E5%AD%A6%E7%94%9F%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E8%B5%9BMISC%E5%8F%AF%E4%B9%90%E5%8A%A0%E5%86%B0/12.png"><br>注意不要少了与壳连接的+号，不然会报错无法运行。</p><p>放到浏览器控制台跑一下：<br><img src="/2021/03/08/2020%E4%B8%8A%E6%B5%B7%E5%A4%A7%E5%AD%A6%E7%94%9F%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E8%B5%9BMISC%E5%8F%AF%E4%B9%90%E5%8A%A0%E5%86%B0/13.png"><br><img src="/2021/03/08/2020%E4%B8%8A%E6%B5%B7%E5%A4%A7%E5%AD%A6%E7%94%9F%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E8%B5%9BMISC%E5%8F%AF%E4%B9%90%E5%8A%A0%E5%86%B0/14.png"><br> 得到flag为flag{e901fe91-bad6-4af7-9963-dad812f5624d}</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;题目附件是一张PNG图片：&lt;br&gt;&lt;img src=&quot;/2021/03/08/2020%E4%B8%8A%E6%B5%B7%E5%A4%A7%E5%AD%A6%E7%94%9F%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E8%B5%9BMISC</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>BUU12</title>
    <link href="http://example.com/2021/03/06/BUU12/"/>
    <id>http://example.com/2021/03/06/BUU12/</id>
    <published>2021-03-06T02:24:49.000Z</published>
    <updated>2021-03-07T05:17:26.504Z</updated>
    
    <content type="html"><![CDATA[<h1 id="真的很杂"><a href="#真的很杂" class="headerlink" title="真的很杂"></a><strong>真的很杂</strong></h1><p>foremost分离出一个压缩包，里面的内容看着像apk文件，考虑进行反汇编</p><p>方法一：apktools</p><p>改后缀名为apk，命令：apktool d 00000010.apk<br><img src="/2021/03/06/BUU12/1.png"><br>生成的00000010文件就是源码了，在\smali\com\example\flag\MainActivity$1.smali文件里发现字符串：”TOO YOUNG TOO SIMPLE:flag{25f991b27f”，”dc2f7a82a2b34”，”86e81c4}”<br><img src="/2021/03/06/BUU12/2.png"><br>猜测flag{25f991b27f?dc2f7a82a2b34?86e81c4}，前一个是字母，后一个数字，爆破即可flag{25f991b27fcdc2f7a82a2b34386e81c4}</p><p>方法二：dex2jar和jd-gui</p><p>解压后的classes.dex放到dex2jar目录，命令：d2j-dex2jar classes.dex<br><img src="/2021/03/06/BUU12/3.png"><br>将生成的classes-dex2jar.jar用jd-gui打开，同样得到：</p><p>flag{25f991b27f?dc2f7a82a2b34?86e81c4}，再爆破，flag{25f991b27fcdc2f7a82a2b34386e81c4}<br><img src="/2021/03/06/BUU12/4.png"><br>作者：Du1in9<br>链接：<a href="https://www.jianshu.com/p/1a318f2b4082">https://www.jianshu.com/p/1a318f2b4082</a><br>来源：简书<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p><hr><hr><hr><h1 id="湖南省赛2019-Findme"><a href="#湖南省赛2019-Findme" class="headerlink" title="[湖南省赛2019]Findme"></a><strong>[湖南省赛2019]Findme</strong></h1><p>下载得到五个图片如图<br><img src="/2021/03/06/BUU12/10.png"></p><blockquote><p><strong>1.png</strong><br>第一张图明显是修改图片大小<br><img src="/2021/03/06/BUU12/5.png"><br>这里有大佬的脚本</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">import zlib</span><br><span class="line">import struct</span><br><span class="line">file &#x3D; &#39;1.png&#39;</span><br><span class="line">fr &#x3D; open(file,&#39;rb&#39;).read()</span><br><span class="line">data &#x3D; bytearray(fr[12:29])</span><br><span class="line">#crc32key &#x3D; eval(str(fr[29:33]).replace(&#39;\\x&#39;,&#39;&#39;).replace(&quot;b&#39;&quot;,&#39;0x&#39;).replace(&quot;&#39;&quot;,&#39;&#39;)) </span><br><span class="line">crc32key &#x3D; 0xC4ED3 </span><br><span class="line">#data &#x3D; bytearray(b&#39;\x49\x48\x44\x52\x00\x00\x01\xF4\x00\x00\x01\xF1\x08\x06\x00\x00\x00&#39;) </span><br><span class="line">n &#x3D; 4095 </span><br><span class="line">for w in range(n): </span><br><span class="line">    width &#x3D; bytearray(struct.pack(&#39;&gt;i&#39;, w))</span><br><span class="line">    for h in range(n): </span><br><span class="line">        height &#x3D; bytearray(struct.pack(&#39;&gt;i&#39;, h)) </span><br><span class="line">        for x in range(4): </span><br><span class="line">            data[x+4] &#x3D; width[x] </span><br><span class="line">            data[x+8] &#x3D; height[x] </span><br><span class="line">            #print(data) </span><br><span class="line">        crc32result &#x3D; zlib.crc32(data) </span><br><span class="line">        if crc32result &#x3D;&#x3D; crc32key: </span><br><span class="line">            print(width,height) </span><br><span class="line">            print(data) </span><br><span class="line">            newpic &#x3D; bytearray(fr) </span><br><span class="line">            for x in range(4): </span><br><span class="line">                newpic[x+16] &#x3D; width[x]</span><br><span class="line">                newpic[x+20] &#x3D; height[x] </span><br><span class="line">            fw &#x3D; open(file+&#39;.png&#39;,&#39;wb&#39;) </span><br><span class="line">            fw.write(newpic) </span><br><span class="line">            fw.close </span><br></pre></td></tr></table></figure><p>复原之后如图所示<br><img src="/2021/03/06/BUU12/6.png"><br>这里又学到了IDAT标识<br>010 editor打开，发现chunk[2]、chunk[3]缺少IDAT标识<br>IDAT十六进制标识为：49 44 41 54，将两个chunk的IDAT在union CTYPE type的位置补上即可得到完整的图片<br><img src="/2021/03/06/BUU12/7.png"><br>在stegsolve中发现了二维码<br><img src="/2021/03/06/BUU12/8.png"><br>解码得到第一段base64<br><img src="/2021/03/06/BUU12/9.png"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1.png &#x3D;&gt; ZmxhZ3s0X3</span><br></pre></td></tr></table></figure><blockquote><p><strong>2.png</strong></p></blockquote><p>zsteg分析后发现了异常，貌似有7z压缩包<br>但是binwalk没有检测也无法分离<br><img src="/2021/03/06/BUU12/11.png"><br>到了010editor提取后无法打开，发现应该是将PK改为了7z<br><img src="/2021/03/06/BUU12/12.png"><br>将7z全部改为PK，发现可以打开了<br><img src="/2021/03/06/BUU12/13.png"><br>将txt文件从大到小排列，得到第二段base64<br><img src="/2021/03/06/BUU12/14.png"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">P2：1RVcmVfc</span><br></pre></td></tr></table></figure><blockquote><p><strong>3.png</strong><br>虚拟机中图片打不开，说明图片是有问题的<br><img src="/2021/03/06/BUU12/15.png"><br>在010editor中检查发现图片的crc值是有问题的<br><img src="/2021/03/06/BUU12/16.png"><br>将每段都提取出来，转换得到第三段base64<br><img src="/2021/03/06/BUU12/17.png"></p></blockquote><blockquote><p><strong>4.png</strong><br>这个就比较简单了，在十六进制尾端直接发现了base64</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">P4：cExlX1BsY</span><br></pre></td></tr></table></figure><p><img src="/2021/03/06/BUU12/18.png"></p><blockquote><p><strong>5.png</strong><br>同样在十六进制尾端<br><img src="/2021/03/06/BUU12/19.png"></p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">P5：Yzcllfc0lN</span><br></pre></td></tr></table></figure><p>组合在一起</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">P1:ZmxhZ3s0X3</span><br><span class="line">P2:1RVcmVfc</span><br><span class="line">P3:3RlZ30&#x3D;</span><br><span class="line">P4:cExlX1BsY</span><br><span class="line">P5:Yzcllfc0lN</span><br></pre></td></tr></table></figure><p>P1是开头，P3是结尾<br>其他的一个一个试得到最终的base64</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ZmxhZ3s0X3Yzcllfc0lNcExlX1BsY1RVcmVfc3RlZ30&#x3D;</span><br></pre></td></tr></table></figure><p>解码得到flag<br><img src="/2021/03/06/BUU12/20.png"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flag&#123;4_v3rY_sIMpLe_PlcTUre_steg&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;真的很杂&quot;&gt;&lt;a href=&quot;#真的很杂&quot; class=&quot;headerlink&quot; title=&quot;真的很杂&quot;&gt;&lt;/a&gt;&lt;strong&gt;真的很杂&lt;/strong&gt;&lt;/h1&gt;&lt;p&gt;foremost分离出一个压缩包，里面的内容看着像apk文件，考虑进行反汇编&lt;/p&gt;
&lt;p</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>BUU11</title>
    <link href="http://example.com/2021/03/05/BUU11/"/>
    <id>http://example.com/2021/03/05/BUU11/</id>
    <published>2021-03-04T23:38:58.000Z</published>
    <updated>2021-03-07T05:02:58.910Z</updated>
    
    <content type="html"><![CDATA[<h1 id="UTCTF2020-basic-forensics"><a href="#UTCTF2020-basic-forensics" class="headerlink" title="[UTCTF2020]basic-forensics"></a><strong>[UTCTF2020]basic-forensics</strong></h1><p>打开后看到了很长的英文文章，还像是啥字频分析，结果直接搜了出来<br><img src="/2021/03/05/BUU11/1.png"><br><img src="/2021/03/05/BUU11/2.png"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">utflag&#123;fil3_ext3nsi0ns_4r3nt_r34l&#125;</span><br></pre></td></tr></table></figure><hr><hr><hr><h1 id="SCTF2019-电单车"><a href="#SCTF2019-电单车" class="headerlink" title="[SCTF2019]电单车"></a><strong>[SCTF2019]电单车</strong></h1><p>打开音频文件看到了长短波，<br><img src="/2021/03/05/BUU11/3.png"><br>半天没搞明白要干嘛，结果发现了原题里有描述</p><blockquote><p>题目描述：截获了一台电动车的钥匙发出的锁车信号，3分钟之内，我要获得它地址位的全部信息。flag内容二进制表示即可。</p></blockquote><p>整理出二进制</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0 0111010010101010011000100 0111010010101010011000100</span><br></pre></td></tr></table></figure><p>地址位是中间的前20个bit:<br>得到flag</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flag&#123;01110100101010100110&#125;</span><br></pre></td></tr></table></figure><p>参考链接地址：<a href="https://www.freebuf.com/articles/wireless/191534.html">https://www.freebuf.com/articles/wireless/191534.html</a></p><hr><hr><hr><h1 id="CTF2019-otaku"><a href="#CTF2019-otaku" class="headerlink" title="*[CTF2019]otaku"></a>*<em>[<em>CTF2019]otaku</em></em></h1><p>始终没明白这个明文攻击<br>大佬的wp(<a href="https://blog.csdn.net/zxnimud5/article/details/108800686">https://blog.csdn.net/zxnimud5/article/details/108800686</a>) </p><hr><hr><hr><h1 id="hashcat"><a href="#hashcat" class="headerlink" title="hashcat"></a><strong>hashcat</strong></h1><p>1文件没有后缀，用file命令后，除了知道有密码，没啥可用信息，binwalk分析后发现是office文件<br><img src="/2021/03/05/BUU11/4.png"><br>将后缀改为doc，发现需要密码<br><img src="/2021/03/05/BUU11/8.png"><br>破解办公文件用Accent OFFICE Password Recovery v5.1 CracKed By Hmily[LCG][LSG]工具<br><img src="/2021/03/05/BUU11/5.png"><br>爆出9919，<br>结果word文件打不开，xls打不开，改后缀为pptx打开了，<br><img src="/2021/03/05/BUU11/6.png"><br>第7张白白的，搜索flag,有，替换颜色。<br><img src="/2021/03/05/BUU11/7.png"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Flag&#123;okYOUWIN&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;UTCTF2020-basic-forensics&quot;&gt;&lt;a href=&quot;#UTCTF2020-basic-forensics&quot; class=&quot;headerlink&quot; title=&quot;[UTCTF2020]basic-forensics&quot;&gt;&lt;/a&gt;&lt;strong&gt;[U</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>BUU10</title>
    <link href="http://example.com/2021/03/04/BUU10/"/>
    <id>http://example.com/2021/03/04/BUU10/</id>
    <published>2021-03-04T10:12:27.000Z</published>
    <updated>2021-03-07T03:35:32.660Z</updated>
    
    <content type="html"><![CDATA[<h1 id="粽子的来历"><a href="#粽子的来历" class="headerlink" title="粽子的来历"></a><strong>粽子的来历</strong></h1><p>打开压缩包里面有4个坏掉了的word文件</p><p><img src="/2021/03/04/BUU10/1.png"><br>放入16进制，每一个word文件中都加了一串字符，<br>在C中看到了题目提示的DBAPP，将C中那一串字符全部改为ff<br><img src="/2021/03/04/BUU10/2.png"><br>打开发现行高不一样，想到了二进制<br><img src="/2021/03/04/BUU10/3.png"><br>1.5倍行高为1，1倍行高为0，得到下列二进制<br><img src="/2021/03/04/BUU10/4.png"><br>将二进制进行md5加密得到flag<br><img src="/2021/03/04/BUU10/5.png"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flag&#123;d473ee3def34bd022f8e5233036b3345&#125;</span><br></pre></td></tr></table></figure><hr><hr><hr><h1 id="wireshark-BSidesSF2019-zippy"><a href="#wireshark-BSidesSF2019-zippy" class="headerlink" title="wireshark [BSidesSF2019]zippy"></a><strong>wireshark [BSidesSF2019]zippy</strong></h1><hr><hr><hr><h1 id="UTCTF2020-file-header"><a href="#UTCTF2020-file-header" class="headerlink" title="[UTCTF2020]file header"></a><strong>[UTCTF2020]file header</strong></h1><p>将文件头改为正确png形式得到flag<br><img src="/2021/03/04/BUU10/6.png"><br><img src="/2021/03/04/BUU10/7.png"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flag&#123;3lit3_h4ck3r&#125;</span><br></pre></td></tr></table></figure><hr><hr><hr><h1 id="WUSTCTF2020-spaceclub"><a href="#WUSTCTF2020-spaceclub" class="headerlink" title="[WUSTCTF2020]spaceclub"></a><strong>[WUSTCTF2020]spaceclub</strong></h1><p>txt打开看不到内容<br>sublime打开全选发现长短点<br>猜测二进制，<br>替换后在线解密,猜测正确<br>ps： 二进制要转16进制后再解ascii<br><img src="/2021/03/04/BUU10/8.png"><br><img src="/2021/03/04/BUU10/9.png"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wctf2020&#123;h3re_1s_y0ur_fl@g_s1x_s1x_s1x&#125;</span><br></pre></td></tr></table></figure><hr><hr><hr><h1 id="ACTF新生赛2020-music"><a href="#ACTF新生赛2020-music" class="headerlink" title="[ACTF新生赛2020]music"></a><strong>[ACTF新生赛2020]music</strong></h1><p>学到了新东西，异或运算</p><p><img src="/2021/03/04/BUU10/10.png"><br>发现十六进制中有很多A1<br><img src="/2021/03/04/BUU10/11.png"><br>猜测对整个原文件进行了异或，使用<code>010 Editor</code>在<code>工具</code>-&gt;<code>十六进制运算</code>-&gt;<code>二进制异或</code>对整个文件内容进行异或<br><img src="/2021/03/04/BUU10/12.png"><br>得到一个音频文件，<br><img src="/2021/03/04/BUU10/13.png"><br>直接听即可得到flag</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flag&#123;abcdfghijk&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;粽子的来历&quot;&gt;&lt;a href=&quot;#粽子的来历&quot; class=&quot;headerlink&quot; title=&quot;粽子的来历&quot;&gt;&lt;/a&gt;&lt;strong&gt;粽子的来历&lt;/strong&gt;&lt;/h1&gt;&lt;p&gt;打开压缩包里面有4个坏掉了的word文件&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/20</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>BUU9</title>
    <link href="http://example.com/2021/03/03/BUU9/"/>
    <id>http://example.com/2021/03/03/BUU9/</id>
    <published>2021-03-03T01:30:18.000Z</published>
    <updated>2021-03-04T10:11:53.017Z</updated>
    
    <content type="html"><![CDATA[<h1 id="GKCTF2020-Harley-Quinn"><a href="#GKCTF2020-Harley-Quinn" class="headerlink" title="[GKCTF2020]Harley Quinn"></a><strong>[GKCTF2020]Harley Quinn</strong></h1><p>打开压缩包内容如下<br><img src="/2021/03/03/BUU9/5.png"><br>有一张图片和一个mav音频<br>听到音频的尾端有电话拨号码，用audacity将其提取出来<br><img src="/2021/03/03/BUU9/1.png"><br>用dtmf2num转出来数字<br><img src="/2021/03/03/BUU9/2.png"><br>九建编码解码出</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ctfisfun</span><br></pre></td></tr></table></figure><p>根据提示下载了FreeFileCamouflage<br>按照如图解出flag<br><img src="/2021/03/03/BUU9/3.png" alt="1"><br>得到flag<br><img src="/2021/03/03/BUU9/4.png"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flag&#123;Pudd1n!!_y0u_F1nd_m3!&#125;</span><br></pre></td></tr></table></figure><hr><hr><hr><h1 id="python-派大星的烦恼"><a href="#python-派大星的烦恼" class="headerlink" title="python 派大星的烦恼"></a><strong>python 派大星的烦恼</strong></h1><hr><hr><hr><h1 id="ACTF新生赛2020-明文攻击"><a href="#ACTF新生赛2020-明文攻击" class="headerlink" title="[ACTF新生赛2020]明文攻击"></a><strong>[ACTF新生赛2020]明文攻击</strong></h1><p>这个明文攻击了两个小时也没破解出来</p><hr><hr><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;GKCTF2020-Harley-Quinn&quot;&gt;&lt;a href=&quot;#GKCTF2020-Harley-Quinn&quot; class=&quot;headerlink&quot; title=&quot;[GKCTF2020]Harley Quinn&quot;&gt;&lt;/a&gt;&lt;strong&gt;[GKCTF2020]</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>BUU8</title>
    <link href="http://example.com/2021/03/01/BUU8/"/>
    <id>http://example.com/2021/03/01/BUU8/</id>
    <published>2021-03-01T02:21:32.000Z</published>
    <updated>2021-03-07T05:38:31.838Z</updated>
    
    <content type="html"><![CDATA[<h1 id="MRCTF2020-不眠之夜"><a href="#MRCTF2020-不眠之夜" class="headerlink" title="[MRCTF2020]不眠之夜"></a><strong>[MRCTF2020]不眠之夜</strong></h1><p>这个题真是搞了大半天<br>看了好多wp都不管用<br>这里要用到montage和gaps两个命令<br>首先用montage命令合成</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">montage *.jpg -tile 10x12 -geometry +0+0 out.jpg</span><br></pre></td></tr></table></figure><p>得到合成后的图片<br><img src="/2021/03/01/BUU8/1.png"></p><p>然后再用gaps恢复</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gaps --image&#x3D;out.jpg --size&#x3D;200</span><br></pre></td></tr></table></figure><p>得到恢复图片<br><img src="/2021/03/01/BUU8/2.png"><br>这里借鉴的这位大佬的<a href="https://www.cnblogs.com/wrnan/p/12912705.html#mrctf2020%E4%B8%8D%E7%9C%A0%E4%B9%8B%E5%A4%9C">wp</a></p><hr><hr><hr><h1 id="python-安洵杯-2019-easy-misc"><a href="#python-安洵杯-2019-easy-misc" class="headerlink" title="python [安洵杯 2019]easy misc"></a><strong>python [安洵杯 2019]easy misc</strong></h1><hr><hr><hr><h1 id="MRCTF2020-Unravel"><a href="#MRCTF2020-Unravel" class="headerlink" title="[MRCTF2020]Unravel!!"></a><strong>[MRCTF2020]Unravel!!</strong></h1><blockquote><p><strong>考察内容:</strong><br>图片隐藏压缩包，aes加密，十六进制尾端隐写，<strong>silenteye</strong></p></blockquote><p>题目内容如图所示</p><p><img src="/2021/03/01/BUU8/3.png"><br>binwalk发现在png图片中有隐藏zip文件却分离不出来<br><img src="/2021/03/01/BUU8/4.png"><br>打开压缩包发现一个名为aes.png的图片<br><img src="/2021/03/01/BUU8/5.png"><br><code>Tokyo</code><br>应该还有aes密文<br>在Look_at_the_file_ending.wav的尾端找到了aes密文<br><img src="/2021/03/01/BUU8/6.png"><br>在线解密得到了win-win.zip的密码<br><img src="/2021/03/01/BUU8/7.png"><br>此wav音频为silenteye隐写<br><img src="/2021/03/01/BUU8/8.png"><br>得到flag</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MRCTF&#123;Th1s_is_the_3nd1n9&#125;</span><br></pre></td></tr></table></figure><hr><hr><hr><h1 id="UTCTF2020-docx"><a href="#UTCTF2020-docx" class="headerlink" title="[UTCTF2020]docx"></a><strong>[UTCTF2020]docx</strong></h1><p>在word文档中未发现flag内容<br>打开document.xml搜索flag、ctf未果<br>在image中发现了flag<br><img src="/2021/03/01/BUU8/9.png"><br><img src="/2021/03/01/BUU8/10.png"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flag&#123;unz1p_3v3ryth1ng&#125;</span><br></pre></td></tr></table></figure><hr><hr><hr><h1 id="python-GKCTF2020-code-obfuscation"><a href="#python-GKCTF2020-code-obfuscation" class="headerlink" title="python [GKCTF2020]code obfuscation"></a><strong>python [GKCTF2020]code obfuscation</strong></h1><p>这个同样看了好久<br>要用到ps和python<br><a href="https://www.cnblogs.com/wrnan/p/12912705.html#gkctf2020code-obfuscation">wp1</a><br><a href="https://blog.csdn.net/hiahiachang/article/details/106317765">wp2</a><br><a href="https://blog.csdn.net/mochu7777777/article/details/109655585">wp3</a></p><hr><hr><hr><h1 id="今日小结"><a href="#今日小结" class="headerlink" title="今日小结"></a><strong>今日小结</strong></h1><ol><li>montage和gaps两个命令</li><li>aes加密</li><li>silenteye隐写</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;MRCTF2020-不眠之夜&quot;&gt;&lt;a href=&quot;#MRCTF2020-不眠之夜&quot; class=&quot;headerlink&quot; title=&quot;[MRCTF2020]不眠之夜&quot;&gt;&lt;/a&gt;&lt;strong&gt;[MRCTF2020]不眠之夜&lt;/strong&gt;&lt;/h1&gt;&lt;p&gt;这个题</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>BUU7</title>
    <link href="http://example.com/2021/02/28/BUU7/"/>
    <id>http://example.com/2021/02/28/BUU7/</id>
    <published>2021-02-28T01:57:58.000Z</published>
    <updated>2021-03-07T05:37:01.440Z</updated>
    
    <content type="html"><![CDATA[<h1 id="BSidesSF2019-diskimage"><a href="#BSidesSF2019-diskimage" class="headerlink" title="[BSidesSF2019]diskimage"></a><strong>[BSidesSF2019]diskimage</strong></h1><p>下载得到如下图片<br><img src="/2021/02/28/BUU7/1.png"><br>kali中file binwalk zsteg 一套，发现有磁盘数据<br><img src="/2021/02/28/BUU7/2.png"><br>导出磁盘数据，恢复删除文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">kali1@kali:~&#x2F;桌面&#x2F;CTF$ zsteg -e b8,rgb,lsb,xy 1.png&gt;disk.dat</span><br><span class="line">kali1@kali:~&#x2F;桌面&#x2F;CTF$ file disk.dat</span><br><span class="line">disk.dat: DOS&#x2F;MBR boot sector, code offset 0x3c+2, OEM-ID &quot;~mitsumi&quot;, root entries 224, sectors 2880 (volumes &lt;&#x3D;32 MB), sectors&#x2F;FAT 9, sectors&#x2F;track 18, serial number 0x7e572f0f, unlabeled, FAT (12 bit), followed by FAT</span><br><span class="line">kali1@kali:~&#x2F;桌面&#x2F;CTF$ testdisk &#x2F;home&#x2F;kali1&#x2F;桌面&#x2F;CTF&#x2F;disk.dat</span><br><span class="line">TestDisk 7.1, Data Recovery Utility, July 2019</span><br><span class="line">Christophe GRENIER &lt;grenier@cgsecurity.org&gt;</span><br><span class="line">https:&#x2F;&#x2F;www.cgsecurity.org</span><br></pre></td></tr></table></figure><p>得到flag<br><img src="/2021/02/28/BUU7/3.png"><br>这里有两个大佬的wp<br><a href="https://blog.csdn.net/mochu7777777/article/details/110079540">wp2</a><br><a href="https://blog.csdn.net/zippo1234/article/details/109238587">wp1</a></p><hr><hr><hr><h1 id="WUSTCTF2020-爬"><a href="#WUSTCTF2020-爬" class="headerlink" title="[WUSTCTF2020]爬"></a><strong>[WUSTCTF2020]爬</strong></h1><p>下载附件</p><p>得到一个文件<br><img src="/2021/02/28/BUU7/4.png"><br>我们查看一下16进制，发现这是PDF的文件头</p><p><img src="/2021/02/28/BUU7/5.png"><br>我们将文件改为pdf</p><p><img src="/2021/02/28/BUU7/6.png"><br>我们发现里面给出提示说flag被图片盖住了，我们需要将图片移动开吗。</p><p>因为PDF无法直接修改，我们这里将PDF转换为了word。<br>来回移动图片，图片分离<br><img src="/2021/02/28/BUU7/7.png"><br>得到一串十六进制代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0x77637466323032307b746831735f31735f405f7064665f616e645f7930755f63616e5f7573655f70686f7430736830707d</span><br></pre></td></tr></table></figure><p>将识别出来的代码复制出来，然后在在线工具进行16进制转字符串。</p><p><img src="/2021/02/28/BUU7/8.png"><br>得到flag</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">wctf2020&#123;th1s_1s_@_pdf_and_y0u_can_use_phot0sh0p&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><hr><hr><hr><h1 id="WUSTCTF2020-girlfriend"><a href="#WUSTCTF2020-girlfriend" class="headerlink" title="[WUSTCTF2020]girlfriend"></a><strong>[WUSTCTF2020]girlfriend</strong></h1><p>听起来像是在打电话输入号码的声音，猜测DTMF拨号音识别，有个程序可以识别一下dtmf2num.exe</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">999*666*88*2*777*33*6*999*4*4444*777*555*333*777*444*33*66*3*7777</span><br></pre></td></tr></table></figure><p>这个是手机键盘密码<br>解此段密码得到flag</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flag&#123;youaremygirlfriends&#125;</span><br></pre></td></tr></table></figure><hr><hr><hr><h1 id="MRCTF2020-CyberPunk"><a href="#MRCTF2020-CyberPunk" class="headerlink" title="[MRCTF2020]CyberPunk"></a><strong>[MRCTF2020]CyberPunk</strong></h1><p>把日期改到2020.9.17得到flag</p><p><img src="/2021/02/28/BUU7/9.png"></p><p>MRCTF{We1cOm3_70_cyber_security}</p><hr><hr><hr><h1 id="wireshark-USB"><a href="#wireshark-USB" class="headerlink" title="wireshark USB"></a><strong>wireshark USB</strong></h1><hr><hr><hr><h1 id="python-SWPU2019-Network"><a href="#python-SWPU2019-Network" class="headerlink" title="python [SWPU2019]Network"></a><strong>python [SWPU2019]Network</strong></h1><hr><hr><hr><h1 id="python-GUET-CTF2019-虚假的压缩包"><a href="#python-GUET-CTF2019-虚假的压缩包" class="headerlink" title="python  [GUET-CTF2019]虚假的压缩包"></a><strong>python  [GUET-CTF2019]虚假的压缩包</strong></h1><hr><hr><hr><h1 id="wireshark-蜘蛛侠呀"><a href="#wireshark-蜘蛛侠呀" class="headerlink" title="wireshark 蜘蛛侠呀"></a><strong>wireshark 蜘蛛侠呀</strong></h1><hr><hr><hr><h1 id="wireshark-SUCTF2018-followme"><a href="#wireshark-SUCTF2018-followme" class="headerlink" title="wireshark[SUCTF2018]followme"></a><strong>wireshark[SUCTF2018]followme</strong></h1><hr><hr><hr><h1 id="RCTF2019-draw"><a href="#RCTF2019-draw" class="headerlink" title="[RCTF2019]draw"></a><strong>[RCTF2019]draw</strong></h1><p>打开得到下列代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cs pu lt 90 fd 500 rt 90 pd fd 100 rt 90 repeat 18[fd 5 rt 10] lt 135 fd 50 lt 135 pu bk 100 pd setcolor pick [ red orange yellow green blue violet ] repeat 18[fd 5 rt 10] rt 90 fd 60 rt 90 bk 30 rt 90 fd 60 pu lt 90 fd 100 pd rt 90 fd 50 bk 50 setcolor pick [ red orange yellow green blue violet ] lt 90 fd 50 rt 90 fd 50 pu fd 50 pd fd 25 bk 50 fd 25 rt 90 fd 50 pu setcolor pick [ red orange yellow green blue violet ] fd 100 rt 90 fd 30 rt 45 pd fd 50 bk 50 rt 90 fd 50 bk 100 fd 50 rt 45 pu fd 50 lt 90 pd fd 50 bk 50 rt 90 setcolor pick [ red orange yellow green blue violet ] fd 50 pu lt 90 fd 100 pd fd 50 rt 90 fd 25 bk 25 lt 90 bk 25 rt 90 fd 25 setcolor pick [ red orange yellow green blue violet ] pu fd 25 lt 90 bk 30 pd rt 90 fd 25 pu fd 25 lt 90 pd fd 50 bk 25 rt 90 fd 25 lt 90 fd 25 bk 50 pu bk 100 lt 90 setcolor pick [ red orange yellow green blue violet ] fd 100 pd rt 90 arc 360 20 pu rt 90 fd 50 pd arc 360 15 pu fd 15 setcolor pick [ red orange yellow green blue violet ] lt 90 pd bk 50 lt 90 fd 25 pu home bk 100 lt 90 fd 100 pd arc 360 20 pu home</span><br></pre></td></tr></table></figure><p><a href="https://www.calormen.com/jslogo/">在线解logo码</a>得到flag<br><img src="/2021/02/28/BUU7/10.png"><br>flag{RCTF_HeyLogo}</p><hr><hr><hr><h1 id="XMAN2018排位赛-通行证"><a href="#XMAN2018排位赛-通行证" class="headerlink" title="[XMAN2018排位赛]通行证"></a><strong>[XMAN2018排位赛]通行证</strong></h1><p>打开先base64解码<br><img src="/2021/02/28/BUU7/11.png"><br>这里卡了好久，怎么解不出来<br><img src="/2021/02/28/BUU7/12.png"><br>看了大佬们说解栅栏，每组七个，<br>找了好久发现是用栅栏给它加密<br>菜到解不出签到题<br><img src="/2021/02/28/BUU7/13.png"><br>最后得到flag<br><img src="/2021/02/28/BUU7/14.png"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xman&#123;oyay_now_you_get_it&#125;</span><br></pre></td></tr></table></figure><hr><hr><hr><h1 id="今日小结"><a href="#今日小结" class="headerlink" title="今日小结"></a><strong>今日小结</strong></h1><ol><li>磁盘数据，恢复删除文件</li><li>PDF转换为了word</li><li>dtmf2num.exe</li><li>手机键盘密码</li><li>在线解logo码 </li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;BSidesSF2019-diskimage&quot;&gt;&lt;a href=&quot;#BSidesSF2019-diskimage&quot; class=&quot;headerlink&quot; title=&quot;[BSidesSF2019]diskimage&quot;&gt;&lt;/a&gt;&lt;strong&gt;[BSidesSF20</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>BUU6</title>
    <link href="http://example.com/2021/02/27/BUU6/"/>
    <id>http://example.com/2021/02/27/BUU6/</id>
    <published>2021-02-27T04:37:03.000Z</published>
    <updated>2021-03-07T05:32:20.605Z</updated>
    
    <content type="html"><![CDATA[<h1 id="SUCTF2018-single-dog"><a href="#SUCTF2018-single-dog" class="headerlink" title="[SUCTF2018]single dog"></a><strong>[SUCTF2018]single dog</strong></h1><p>binwalk分析发现隐藏文件，分离后得到txt文件<br><img src="/2021/02/27/BUU6/1.png"><br>aaencode解密得到flag<br><img src="/2021/02/27/BUU6/2.png"><br>flag{happy double eleven}</p><hr><hr><hr><h1 id="wireshark-V-amp-N2020-公开赛-拉胯的三条命令"><a href="#wireshark-V-amp-N2020-公开赛-拉胯的三条命令" class="headerlink" title="wireshark[V&amp;N2020 公开赛]拉胯的三条命令"></a><strong>wireshark[V&amp;N2020 公开赛]拉胯的三条命令</strong></h1><hr><hr><hr><h1 id="python-安洵杯-2019-吹着贝斯扫二维码"><a href="#python-安洵杯-2019-吹着贝斯扫二维码" class="headerlink" title="python[安洵杯 2019]吹着贝斯扫二维码"></a><strong>python[安洵杯 2019]吹着贝斯扫二维码</strong></h1><hr><hr><hr><h1 id="从娃娃抓起"><a href="#从娃娃抓起" class="headerlink" title="从娃娃抓起"></a><strong>从娃娃抓起</strong></h1><p>第一行为中文电码，第二行为五笔输入法<br><img src="/2021/02/27/BUU6/3.png"><br>解码得到<br><img src="/2021/02/27/BUU6/4.png"><br><img src="/2021/02/27/BUU6/5.png"><br>人工智能也要从娃娃抓起<br><img src="/2021/02/27/BUU6/6.png"><br>得到flag{3b4b5dccd2c008fe7e2664bd1bc19292}</p><hr><hr><hr><h1 id="小易的U盘"><a href="#小易的U盘" class="headerlink" title="小易的U盘"></a><strong>小易的U盘</strong></h1><p>打开压缩包发现这里有线索<br><img src="/2021/02/27/BUU6/7.png"><br><img src="/2021/02/27/BUU6/8.png"><br>这里不知道该怎么搞了，看了wp，要放入ida查看<br><img src="/2021/02/27/BUU6/9.png"></p><hr><hr><hr><h1 id="pythn-DDCTF2018"><a href="#pythn-DDCTF2018" class="headerlink" title="pythn[DDCTF2018]"></a><strong>pythn[DDCTF2018]</strong></h1><hr><hr><hr><h1 id="wireshark-ACTF新生赛2020-swp"><a href="#wireshark-ACTF新生赛2020-swp" class="headerlink" title="wireshark[ACTF新生赛2020]swp"></a><strong>wireshark[ACTF新生赛2020]swp</strong></h1><hr><hr><hr><h1 id="wireshark百里挑一"><a href="#wireshark百里挑一" class="headerlink" title="wireshark百里挑一"></a><strong>wireshark百里挑一</strong></h1><hr><hr><hr><h1 id="WUSTCTF2020-alison-likes-jojo"><a href="#WUSTCTF2020-alison-likes-jojo" class="headerlink" title="[WUSTCTF2020]alison_likes_jojo"></a><strong>[WUSTCTF2020]alison_likes_jojo</strong></h1><p>binwalk分析第一张图片发现有隐藏压缩包<br>使用命令提取出来<br><img src="/2021/02/27/BUU6/10.png"><br>用数字爆破得到密码888866，<br><img src="/2021/02/27/BUU6/11.png"><br>多次解base64，得到密码 <code>killerqueen</code><br>outguess得到flag<br><img src="/2021/02/27/BUU6/12.png"><br>wctf2020{pretty_girl_alison_likes_jojo}</p><hr><hr><hr><h1 id="GUET-CTF2019-zips"><a href="#GUET-CTF2019-zips" class="headerlink" title="[GUET-CTF2019]zips"></a><strong>[GUET-CTF2019]zips</strong></h1><p>打开压缩包需要输入密码，使用ARCHPR爆破，密码为：723456<br><img src="/2021/02/27/BUU6/13.png"><br>发现111.zip伪加密,利用winhex修改数据<br><img src="/2021/02/27/BUU6/14.png"><br> 查看setup.sh<br><img src="/2021/02/27/BUU6/15.png"><br> flag.zip为掩码爆破，因为时间戳和出题当时不太一样所以往前推，利用ARCHPR设置掩码15???.?? 掩码符号为**?**<br><img src="/2021/02/27/BUU6/16.png"><br>得到flag<br><img src="/2021/02/27/BUU6/17.png"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flag&#123;fkjabPqnLawhvuikfhgzyffj&#125;</span><br></pre></td></tr></table></figure><hr><hr><hr><h1 id="wireshark-安洵杯-2019-Attack"><a href="#wireshark-安洵杯-2019-Attack" class="headerlink" title="wireshark[安洵杯 2019]Attack"></a><strong>wireshark[安洵杯 2019]Attack</strong></h1><hr><hr><hr><h1 id="SUCTF-2019-Game"><a href="#SUCTF-2019-Game" class="headerlink" title="[SUCTF 2019]Game"></a><strong>[SUCTF 2019]Game</strong></h1><p> index.html中发现一串base32<br><img src="/2021/02/27/BUU6/18.png"><br><img src="/2021/02/27/BUU6/19.png"><br>并不是真的flag，但是这个后面有用，看到另外一张图，LSB发现一串base64<br><img src="/2021/02/27/BUU6/20.png"><br>看了wp，这串base64解码后头部是Salted，应该是AES或者3DES<br><img src="/2021/02/27/BUU6/21.png"><br>suctf{U_F0und_1t}</p><hr><hr><hr><h1 id="python-MRCTF2020-千层套路"><a href="#python-MRCTF2020-千层套路" class="headerlink" title="python[MRCTF2020]千层套路"></a><strong>python[MRCTF2020]千层套路</strong></h1><hr><hr><hr><h1 id="BJDCTF-2nd-开场曲"><a href="#BJDCTF-2nd-开场曲" class="headerlink" title="BJDCTF 2nd- -开场曲"></a><strong>BJDCTF 2nd- -开场曲</strong></h1><p><a href="https://blog.csdn.net/qq_42016346/article/details/105039640">大佬的wp</a></p><hr><hr><hr><h1 id="NPUCTF2020-签到"><a href="#NPUCTF2020-签到" class="headerlink" title="[NPUCTF2020]签到"></a><strong>[NPUCTF2020]签到</strong></h1><h1 id="本日小结"><a href="#本日小结" class="headerlink" title="本日小结"></a><strong>本日小结</strong></h1><ol><li>中文电码</li><li>五笔输入法</li><li>小易的U盘 ida</li><li>掩码爆破</li><li>头部是Salted，应该是AES或者3DES</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;SUCTF2018-single-dog&quot;&gt;&lt;a href=&quot;#SUCTF2018-single-dog&quot; class=&quot;headerlink&quot; title=&quot;[SUCTF2018]single dog&quot;&gt;&lt;/a&gt;&lt;strong&gt;[SUCTF2018]single</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>BUU5</title>
    <link href="http://example.com/2021/02/25/BUU5/"/>
    <id>http://example.com/2021/02/25/BUU5/</id>
    <published>2021-02-25T01:56:19.000Z</published>
    <updated>2021-03-07T05:37:05.789Z</updated>
    
    <content type="html"><![CDATA[<h1 id="MRCTF2020-你能看懂音符吗"><a href="#MRCTF2020-你能看懂音符吗" class="headerlink" title="[MRCTF2020]你能看懂音符吗"></a><strong>[MRCTF2020]你能看懂音符吗</strong></h1><p>打开发现并没有什么内容，搞不出来卡了wp，是word隐藏文字<br><img src="/2021/02/25/BUU5/1.png"><br>还有一种方法是查看document.xml<br><img src="/2021/02/25/BUU5/2.png"><br>去解音符得到flag<br><img src="/2021/02/25/BUU5/3.png"></p><hr><hr><hr><h1 id="wireshark-john-in-the-middle"><a href="#wireshark-john-in-the-middle" class="headerlink" title="wireshark john-in-the-middle"></a><strong>wireshark john-in-the-middle</strong></h1><hr><hr><hr><h1 id="GUET-CTF2019-KO"><a href="#GUET-CTF2019-KO" class="headerlink" title="[GUET-CTF2019]KO"></a><strong>[GUET-CTF2019]KO</strong></h1><p>ook编码，白给</p><hr><hr><hr><h1 id="HBNIS2018-caesar"><a href="#HBNIS2018-caesar" class="headerlink" title="[HBNIS2018]caesar"></a><strong>[HBNIS2018]caesar</strong></h1><p>凯撒白给</p><hr><hr><hr><h1 id="MRCTF2020-ezmisc"><a href="#MRCTF2020-ezmisc" class="headerlink" title="[MRCTF2020]ezmisc"></a><strong>[MRCTF2020]ezmisc</strong></h1><p>虚拟机中报错，修改大小得到flag<br><img src="/2021/02/25/BUU5/4.png"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flag&#123;1ts_vEryyyyyy_ez!&#125;</span><br></pre></td></tr></table></figure><hr><hr><hr><h1 id="HBNIS2018-低个头"><a href="#HBNIS2018-低个头" class="headerlink" title="[HBNIS2018]低个头"></a><strong>[HBNIS2018]低个头</strong></h1><p>键盘密码CTF<br><img src="/2021/02/25/BUU5/5.png"></p><hr><hr><hr><h1 id="python-zip"><a href="#python-zip" class="headerlink" title="python zip"></a><strong>python zip</strong></h1><p><a href="https://blog.csdn.net/weixin_45897326/article/details/104021695">大佬的wp</a></p><hr><hr><hr><h1 id="python-GXYCTF2019-SXMgdGhpcyBiYXNlPw"><a href="#python-GXYCTF2019-SXMgdGhpcyBiYXNlPw" class="headerlink" title="python[GXYCTF2019]SXMgdGhpcyBiYXNlPw=="></a><strong>python[GXYCTF2019]SXMgdGhpcyBiYXNlPw==</strong></h1><p><a href="https://www.yuque.com/jxswcy/buuoj-wp/ltyguh">wp地址1</a><br><a href="https://www.pythonf.cn/read/156745">wp地址2</a></p><hr><hr><hr><h1 id="ACTF新生赛2020-NTFS数据流"><a href="#ACTF新生赛2020-NTFS数据流" class="headerlink" title="[ACTF新生赛2020]NTFS数据流"></a><strong>[ACTF新生赛2020]NTFS数据流</strong></h1><p>放入ntfs扫描得到flag<br><img src="/2021/02/25/BUU5/6.png"></p><hr><hr><hr><h1 id="我吃三明治"><a href="#我吃三明治" class="headerlink" title="我吃三明治"></a><strong>我吃三明治</strong></h1><p>binwalk分析发现是两个jpg文件拼接而成，<br>两个图片中没有发现内容，在拼接处发现了base32<br><img src="/2021/02/25/BUU5/7.png"><br>解base32得到flag<br><img src="/2021/02/25/BUU5/8.png"><br>flag{6f1797d4080b29b64da5897780463e30}</p><hr><hr><hr><h1 id="RoarCTF2019-黄金6年"><a href="#RoarCTF2019-黄金6年" class="headerlink" title="[RoarCTF2019]黄金6年"></a><strong>[RoarCTF2019]黄金6年</strong></h1><p>这是个长见识的题，视频里有四个二维码，最后一个最难发现，要把屏幕亮度调到最大<br><img src="/2021/02/25/BUU5/9.png"><br>在视频十六进制尾端发现base64，<br><img src="/2021/02/25/BUU5/10.png"><br>转出来base64发现是一个rar压缩包，放入16进制编译器怎么保存都打不开，<br>看了wp，知道要转出来16进制<br><img src="/2021/02/25/BUU5/11.png"><br>四个二维码内容拼起来是rar压缩包的密码。<br><img src="/2021/02/25/BUU5/12.png"></p><hr><hr><hr><h1 id="间谍启示录"><a href="#间谍启示录" class="headerlink" title="间谍启示录"></a><strong>间谍启示录</strong></h1><p>foremost分离iso文件后得到一个rar压缩包<br>wine flag.exe运行压缩包中的flag.exe文件dedaoflag</p><h1 id="本日小结"><a href="#本日小结" class="headerlink" title="本日小结"></a><strong>本日小结</strong></h1><ol><li>word隐藏文字</li><li>键盘密码</li><li>NTFS数据流</li><li>Kinovea</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;MRCTF2020-你能看懂音符吗&quot;&gt;&lt;a href=&quot;#MRCTF2020-你能看懂音符吗&quot; class=&quot;headerlink&quot; title=&quot;[MRCTF2020]你能看懂音符吗&quot;&gt;&lt;/a&gt;&lt;strong&gt;[MRCTF2020]你能看懂音符吗&lt;/strong</summary>
      
    
    
    
    
  </entry>
  
</feed>
